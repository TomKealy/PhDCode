head	1.30;
access;
symbols;
locks; strict;
comment	@% @;


1.30
date	2008.03.04.14.47.33;	author ers;	state Exp;
branches;
next	1.29;

1.29
date	2006.10.01.08.50.08;	author ers;	state Exp;
branches;
next	1.28;

1.28
date	2006.04.23.02.21.53;	author ers;	state Exp;
branches;
next	1.27;

1.27
date	2006.04.22.13.10.07;	author ers;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.22.05.18.44;	author ers;	state Exp;
branches;
next	1.25;

1.25
date	2006.03.22.01.23.40;	author ers;	state Exp;
branches;
next	1.24;

1.24
date	2006.03.20.13.40.10;	author ers;	state Exp;
branches;
next	1.23;

1.23
date	2006.03.20.03.38.37;	author ers;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.19.16.07.34;	author ers;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.05.03.43.09;	author ers;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.11.01.14.13;	author ers;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.03.23.58.34;	author ers;	state Exp;
branches;
next	1.18;

1.18
date	2005.08.03.23.48.40;	author ers;	state Exp;
branches;
next	1.17;

1.17
date	2005.08.03.21.27.08;	author ers;	state Exp;
branches;
next	1.16;

1.16
date	2005.08.03.01.24.44;	author ers;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.16.19.28.41;	author ers;	state Exp;
branches;
next	1.14;

1.14
date	2005.06.29.00.02.33;	author ers;	state Exp;
branches;
next	1.13;

1.13
date	2005.06.28.23.52.32;	author ers;	state Exp;
branches;
next	1.12;

1.12
date	2005.06.26.22.07.06;	author ers;	state Exp;
branches;
next	1.11;

1.11
date	2005.06.26.14.52.00;	author ers;	state Exp;
branches;
next	1.10;

1.10
date	2005.06.21.23.37.19;	author ers;	state Exp;
branches;
next	1.9;

1.9
date	2005.06.13.12.05.48;	author ers;	state Exp;
branches;
next	1.8;

1.8
date	2005.06.12.02.22.21;	author ers;	state Exp;
branches;
next	1.7;

1.7
date	2005.06.06.21.12.18;	author ers;	state Exp;
branches;
next	1.6;

1.6
date	2005.06.04.22.48.59;	author ers;	state Exp;
branches;
next	1.5;

1.5
date	2005.06.04.20.11.30;	author ers;	state Exp;
branches;
next	1.4;

1.4
date	2005.06.04.16.19.46;	author ers;	state Exp;
branches;
next	1.3;

1.3
date	2005.06.04.00.31.30;	author ers;	state Exp;
branches;
next	1.2;

1.2
date	2005.06.01.14.02.06;	author ers;	state Exp;
branches;
next	1.1;

1.1
date	2005.05.30.18.12.08;	author ers;	state Exp;
branches;
next	;


desc
@@


1.30
log
@*** empty log message ***
@
text
@\documentclass{amsart}
\usepackage[margin=0.75in]{geometry}
\usepackage{hyperref}
\usepackage{pslatex}
\usepackage{superdate}
\usepackage{graphicx}
\usepackage{multicol}

\title[Matgraph]{MATGRAPH: A MATLAB Toolbox for Graph Theory}
\author[Ed Scheinerman]{Edward R. Scheinerman}
\address{Department of Applied Mathematics and Statistics\\
  The Johns Hopkins University\\
  Baltimore, Maryland 21218-2682 USA}
\email{ers@@jhu.edu}

\newcommand\matlab{MATLAB}
\newcommand\matgraph{\textsc{Matgraph}}
\newcommand\ER{Erd\H{o}s-R\'enyi}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\oitem}{\item[$\circ$]}

\date{\superdate}

\begin{document}

\maketitle

\begin{multicols}{2}[\section*{Overview}]

\matgraph\ is a toolbox for working with simple\footnote{Simple graphs
  are undirected graphs without loops or multiple edges.} graphs in
\matlab. The goal is to make interactive graph theory exploration
simple and efficient. 

In order to use this toolbox, you need a copy of \matlab, available
from The MathWorks. A few of the \matgraph\ functions require the
additional Optimization Toolbox, also available from The MathWorks.

This document gives an overview of the \matgraph\ toolbox. More
information can be found in the accompanying web pages (see
\S\ref{sect:documentation}). 


In addition to providing a \verb|graph| class, \matgraph\ also
defines helper classes for working with permutations
(see~\S\ref{sect:perms}) and partitions
(see~\S\ref{sect:partition}).

\end{multicols}
\hrule
\begin{multicols}{2}[\section{Getting \matgraph}]
\label{sect:getting}

\subsection{Download and install}

\matgraph\ is available for free from my web site. Go to
\begin{verbatim}
http://www.ams.jhu.edu/~ers/matgraph
\end{verbatim}
and select the link in the sentence
``You can download Matgraph by \underline{clicking here}.''

This should cause the file \verb|matgraph-X.X.tgz| to be downloaded to
your computer. (The \verb|X.X| is the version number.) This is a
compressed archive. To unpack on a UNIX system, give the command
\begin{verbatim}
tar xfz matgraph-X.X.tgz
\end{verbatim}
(where \verb|X.X| is replaced by the correct version number). On other
computers, double clicking on the file's icon should serve the same
purpose.

This should create a directory named \verb|matgraph|. You may move
this directory to any convenient location on your hard drive.  




\subsection{License}

This software is copyrighted by Edward R.~Scheinerman and released
free of charge under the GNU General Purpose Licenses. A copy of this
license can be found at
\begin{verbatim}
http://www.gnu.org/licenses/gpl.html
\end{verbatim}

I would like to make this tool as useful to as many people as
possible. I invite you to send me improvements for the current
\verb|.m| files as well as new \verb|.m| files for added
functionality.



\end{multicols}
\hrule
\begin{multicols}{2}[\section{Using \matgraph}]
\label{sect:using}


\subsection{Basic principles}
\label{subsect:basic-principles}
We assume the reader is familiar with \matlab. Before we discuss how
to use \matgraph, it is crucial that the following basic principles be
understood.
\begin{itemize}
\item All graphs handled by \matgraph\ are simple and undirected. That
  is, these graphs do not have loops or multiple edges. Each pair of
  distinct vertices either is not adjacent or else is joined by a
  single edge.

\item The vertex set of all graphs in \matgraph\ is always of the form
  $\{1,2,\ldots,n\}$ where $n\ge0$ is the number of vertices in the
  graph. 

  An important consequence of this is that when a vertex is deleted
  from a graph, all vertices with higher value are renumbered. 
  
\item All graphs in \matgraph\ are specially defined \verb|graph|
  objects. They do not behave in the same manner as, say, matrices in
  \matlab. For the sake of efficiency, \matgraph\ functions are
  capable of modifying their arguments.
  
  Most \matlab\ functions use \emph{call by value} semantics. That is,
  a \emph{copy} of the argument is sent to the function. For example,
  suppose we have a function named \verb|func| defined in a file
  \verb|func.m|. In \matlab, issuing the command \verb|func(A)| does
  not affect the value held in the ordinary variable \verb|A|.
  
  \matgraph, however, is designed differently. Function arguments of
  type \verb|graph| use \emph{call by reference} semantics. This means
  that a command such as \verb|add(g,2,4)| can modify the graph
  \verb|g| (in this case, by adding an edge joining vertices \verb|2|
  and \verb|4|).
  
  Not all \matgraph\ functions modify their arguments, but they all
  use call by reference for \verb|graph| arguments. For functions that are
  capable of modifying graphs, the graph that is modified is always the
  \emph{first} argument to the function. For example, \matgraph\
  provides a \verb|line_graph| function. The command
\begin{verbatim}
line_graph(g,h)
\end{verbatim}
  overwrites \verb|g| with the line graph of \verb|h|. The graph
  \verb|h| is not affected. For more detail, see \S\ref{subsection:declare}.

\item As a consequence of how graphs are stored in \verb|matgraph|,
  the only time a \verb|graph| variable should appear on the left hand
  side of an assignment statement is when the variable is initialized
  like this:
\begin{verbatim}
g = graph
\end{verbatim}
  At no other time should a \verb|graph| variable appear to the left
  of an equal sign.

\end{itemize}




\subsection{Starting \matgraph}
\label{subsect:getting-started}

Launch \matlab\ and be sure that the \matgraph\ directory is visible
on \matlab's path. This can be done with \matlab's \verb|addpath|
function. For example:
\begin{verbatim}
addpath('/home/betty/programming/matgraph/')
\end{verbatim}
assuming Betty placed the \verb|matgraph| directory inside a folder
named \verb|programming| on her computer. 

The next step is to initialize the \matgraph\ system. This is done
by giving the following command:
\begin{verbatim}
graph_init
\end{verbatim}
This sets up hidden data structures (see
\S\ref{sect:under-the-hood}) used by \matgraph. 
\matlab\ responds:
\begin{verbatim}
Graph system initialized. Number of slots = 500.
\end{verbatim}
\matgraph\ is now ready to work with graphs. By default, the system
can handle 500 different graphs. This should be adequate for most
purposes. However, if you need an array of, say, 1000 graphs, then
this is not sufficient. Alternatively, \matgraph\ may be initialized
with an explicit argument specifying the number of ``slots'' (place
holders for graphs) like this:
\begin{verbatim}
graph_init(20000)
\end{verbatim}

If you ever wish to delete all of the hidden data structures
(and thereby erasing all graphs held therein), use the function
\verb|graph_destroy|. 


See also\footnote{See \S\ref{sect:documentation} for a description of
  the web-based information on all \matgraph\ functions. When we
  direct the reader to see a particular function, we typically mean to
  view that function's documentation with a web browser or by using
  \matlab's \texttt{help} command.}  the
\verb|free_all|, \verb|num_available|, and \verb|max_available|
functions.




\subsection{Declaring \texttt{graph} objects and memory management}
\label{subsection:declare}



Before working with graphs, it is necessary to declare variable(s) to
be of type \emph{graph}. This runs against \matlab's philosophy that
variables do not need to be declared, but is necessary for the sake of
efficiency. 

To declare a variable, say \verb|g|, to be of type \emph{graph}, we 
give the following command:
\begin{verbatim}
g = graph;
\end{verbatim}
It is helpful to read this as ``let $g$ be a graph.'' 
\textbf{This is the only circumstance in which a graph object may
  appear to the left of an equal sign.}

Behind the scenes, one of the ``slots'' allocated for graphs (by
\verb|graph_init|) is set aside for the graph \verb|g|.

Every time a \verb|graph| variable is declared, one these slots is
taken to hold the data for the graph. If a \verb|graph| variable is no
longer needed, then its slot can be released like this:
\begin{verbatim}
free(g)
\end{verbatim}
If, inadvertently, a \verb|graph| variable is cleared from \matlab's
workspace, there is no convenient way to free the slot it occupied. 

Freeing a graph's slot is not generally necessary when working at
\matlab's command prompt. Graphs can be modified repeatedly and one
need not declare more graph variables than the number of graphs one is
currently considering. 

However, releasing the slot held by a graph is \emph{vital} in
\verb|.m| files. It is often useful for a function to declare a
\verb|graph| variable temporarily. {\bfseries Every graph that is
  created using the \texttt{g=graph} constructor must be released by
  a matching call to \texttt{free(g)}.} Otherwise, each time the
function is invoked, another slot in \matgraph's hidden data structure
is consumed until no slots remain available.

To make a copy of a graph, we must \emph{not} use the statement
\verb|h=g|. Rather, use \verb|copy(h,g)|. 




\subsection{Basic graph operations}

The statement \verb|g=graph| creates a new graph with no vertices or
edges. It is now possible to add and to delete vertices and edges
using the \verb|resize|, \verb|add|, and \verb|delete| functions.  For
each of these, the graph to be modified is the first argument (see the
discussion of basic principles in \S\ref{subsect:basic-principles}).

\begin{itemize}
\item \verb|resize(g,n)| changes the number of vertices in \verb|g| to
  the value held in \verb|n|. If \verb|n| is greater than the number
  of vertices in \verb|g|, then additional, isolated vertices are
  added. On the other hand, if \verb|n| is less than the number of
  vertices in \verb|g|, then the highest numbered vertices are deleted
  leaving a graph with \verb|n| vertices. For example, if \verb|g| has
  $10$ vertices and we invoke the command \verb|resize(g,7)|, then
  vertices $8$, $9$, and $10$ are deleted (and all edges incident on
  these vertices are also deleted). 

\item \verb|add(g,u,v)| adds an edge between \verb|u| and \verb|v| to
  the graph. If either of these values is nonpositive, or if they are
  equal, nothing happens. If either \verb|u| or \verb|v| is greater
  than the number of vertices currently in \verb|g|, the graph is
  expanded to have $\max\{$\verb|u|,\verb|v|$\}$ vertices. 
  
  Another way to use \verb|add| is like this: \verb|add(g,elist)|
  where \verb|elist| is a $k\times 2$ array of positive integers. Each
  row of \verb|elist| is considered an edge, and all of these edges
  are added to the graph. If any end point of any edge is larger than
  the number of vertices currently in the graph, the graph is resized
  to accommodate.

  The automatic resizing has the potential side effect of adding
  isolated vertices. For example, if \verb|g| has 5 vertices, and we
  then give the command \verb|add(g,3,7)| the graph is resized to have
  $7$ vertices. Vertex $6$ is added as an isolated vertex.
  
  Remember: The vertex set of all graphs in \matgraph\ are always of
  the form $\{1,2,\ldots,n\}$ where $n\ge0$.


\item \verb|delete| is used to delete vertices or edges from a
  graph. 

  \begin{itemize}
  \item \verb|delete(g,v)| deletes the vertex \verb|v| from the graph.
    (If \verb|v| is not a vertex of the graph, there is no effect.)
    
    All vertices with number greater than \verb|v| have their values
    decreased by $1$. For example, suppose \verb|g| is a path graph
    with edges $1\sim2\sim3\sim4\sim5$.  When we give the command
    \verb|delete(g,3)| vertex $3$ is deleted from the graph, and
    vertices $4$ and $5$ get renamed $3$ and $4$, respectively.  Thus,
    after \verb|delete(g,3)| the vertex set of \verb|g| is
    $\{1,2,3,4\}$ and the only edges are $1\sim2$ and $3\sim4$.
    
  \item \verb|delete(g,vlist)| deletes an entire set of vertices. In
    this form, \verb|vlist| is a $k\times 1$ array of positive
    integers. All vertices in \verb|vlist| are deleted from the graph,
    and then vertices are renamed so the vertex set remains of the
    form $\{1,2,\ldots,n\}$.
    
    For example, if \verb|g| is a cycle on 5 vertices with edges
    $1\sim2\sim3\sim4\sim5\sim1$, then \verb|delete(g,[2;3])| deletes
    vertices $2$ and $3$ from the graph (leaving edges $4\sim 5 \sim
    1$) and then renumbers vertices 4 and 5 with the new names 2 and
    3, so the final result is the path $2\sim3\sim1$.
    
  \item \verb|delete(g,u,v)| deletes the edge between \verb|u| and
    \verb|v| from the graph. If this edge is not present in the graph,
    nothing happens.
    
  \item \verb|delete(g,elist)| deletes a list of edges from the graph.
    The variable \verb|elist| must be a $k\times 2$ array of positive
    integers. 
  \end{itemize}
  
  Point to notice: \verb|delete(g,[3;4])| deletes vertices 3 and 4
  from the graph (second argument is a column vector) whereas
  \verb|delete(g,[3,4])| deletes the edge $3\sim4$ from the graph
  (second argument is a $k\times 2$ array where $k$ happens to equal
  $1$).

  See also the \verb|clear_edges| function that deletes all edges from
  a graph.

\end{itemize}


See also \verb|set_matrix| (described in
\S\ref{subsect:graph-matrix}). See also \verb|contract|. 


\subsection{Standard graphs}

\matgraph\ provides several functions for forming standard
graphs. One of the more versatile is the \verb|complete| function for
creating complete graphs, complete bipartite graphs, and complete
multipartite graphs:
\begin{itemize}
\item \verb|complete(g)| adds all possible edges to \verb|g| without
  changing its vertex set.

\item \verb|complete(g,n)| sets \verb|g| to be the complete graph
  $K_n$. 

\item \verb|complete(g,n,m)| sets \verb|g| to be the complete
  bipartite graph $K_{n,m}$.

\item \verb|complete(g,list)| sets \verb|g| to be the complete
  multipartite graph $K(a_1,a_2,\ldots,a_t)$ where the indices are the
  entries in \verb|list|. 
\end{itemize}

Other general graph builders include \verb|path|, \verb|cycle|,
\verb|grid|, \verb|wheel|, \verb|cube|, \verb|circulant|, and
\verb|paley|. 
Specific graphs can be formed using these: \verb|bucky|,
\verb|dodecahedron|, \verb|icosahedron|, \verb|octahedron|, and
\verb|petersen|.
Various random graphs can be built using these functions:
\verb|random|,
\verb|sprandom|,
\verb|random_bipartite|, and \verb|random_regular|.


\subsection{Graph operations}

\matgraph\ provides a variety of operations to form new graphs from
old. For example, \verb|line_graph(h,g)| sets \verb|h| to be the line
graph\footnote{The line graph of $G$ is a graph $L(G)$ whose vertex
  set is $E(G)$. Two vertices $e_1$ and $e_2$ of $L(G)$ are adjacent
  in $L(G)$ provided, when considered as edges of $G$, they are
  incident with a common vertex.}  of \verb|g|.  Other operations
include \verb|cartesian|, \verb|complement|, \verb|mycielski|,
\verb|induce|, \verb|intersect|, \verb|union|, and \verb|trim|.

Breadth-first and depth-first spanning trees can be found using
\verb|bfstree| and \verb|dfstree|. See also \verb|nsptrees|. 

\subsection{Graph inspectors}
\label{subsect:inspectors}

The functions \verb|nv(g)| and \verb|ne(g)| give the number of
vertices and edges of \verb|g|. These two values are returned by
\verb|size(g)| in a $1\times2$ array. 

There are two ways to see if an edge is present in a graph \verb|g|.
The command \verb|has(g,u,v)| returns $1$ (for true) if the edge
between \verb|u| and \verb|v| is present in \verb|g|, and $0$
otherwise. Alternatively, the same result is produced by
\verb|g(u,v)|.

The neighborhood of a vertex is returned by the command
\verb|neighbors(g,v)|; the result is a list (one-dimensional array) of
the vertices adjacent to \verb|v|. The same result is returned by
\verb|g(v)|. 

The degree of a vertex is given by \verb|deg(g,v)|. With only a single
argument, \verb|deg(g)| returns the degree sequence of the graph.

\verb|find_path(g,u,v)| finds a shortest path from \verb|u| to
\verb|v| (returned as a list of vertices on the path); if no such path
exists, an empty array is returned. 

\verb|isconnected(g)| returns $1$ (true) if \verb|g| is connected and
$0$ (false) otherwise. 

The components of a graph can be found using
\verb|components(g)|. This returns a partition object (see
\S\ref{sect:partition}) each of whose blocks is the vertex set of a
component of \verb|g|.

The distance between vertices can be found with
\verb|dist(g,u,v)|. The form \verb|dist(g,u)| returns an array giving
the distances from \verb|u| to all the vertices in the graph. Calling
\verb|dist(g)| returns a square matrix giving the distances between
all pairs of vertices. See \verb|diam|.



\subsection{Graph--matrix conversions}
\label{subsect:graph-matrix}

The adjacency matrix of a graph is returned by \verb|matrix(g)|. This
returns a square \emph{logical} matrix. To use this matrix
arithmetically, convert it to class \verb|double|; for example, the
following command returns the eigenvalues of (the adjacency matrix
of) a graph:
\begin{verbatim}
eig(double(matrix(g)))
\end{verbatim}

Conversely, given a square, symmetric, zero-one, zero-diagonal matrix
\verb|A|, we can set \verb|g| to have this matrix as its adjacency
matrix like this: \verb|set_matrix(g,A)|. 

See also \verb|spy|, \verb|laplacian|, and \verb|incidence_matrix|. 


\subsection{Graph invariants and partitions}
\label{subsect:invariants}

In addition to basic information functions described in
\S\ref{subsect:inspectors}, \matgraph\ can calculate other invariants
and features of graphs of interest to graph theorists. These include
\verb|alpha| (independence number), \verb|omega| (clique number), and
\verb|dom| (domination number). (All three of these use the integer
programming facilities in \matlab's Optimization Toolbox.)
See also \verb|diam|. 

The \verb|bipartition| function determines whether a graph is
bipartite;  if it is, it returns the bipartition as a \verb|partition|
object (see \S\ref{sect:partition}). Otherwise (the graph is not
bipartite) \verb|bipartition| returns an empty partition.

A graph coloring algorithm is available in the \verb|color| function.
This returns a partition of the vertex set of a graph into independent
sets by a greedy coloring algorithm (step through the vertices in
decreasing degree order and give the first available color to each
vertex in turn). Alas, this generally does not find a coloring with
$\chi(G)$ colors. 

The chromatic polynomial of a graph can be found for small
graphs. For example:
\begin{verbatim}
>> g = graph;
>> cycle(g,5)
>> chromatic_poly(g)
ans =
     1    -5    10   -10     4     0
\end{verbatim}
shows that the chromatic polynomial of $C_5$ is
$$x^5-5x^4+10x^3-10x^2+4x.$$



\subsection{Input-output}
\label{subsect:io}

\matgraph\ can read and write graphs in files on the user's hard
disk. 

Suppose the user wishes to build a graph using some other software
(such as a C program written by the user) and then read that graph
into \matgraph. To do this, the data should be saved in a file as a
list of edges. Each line of the file should contain exactly two
integers separated by white space. These integers should range from
$1$ to the number of vertices in the graph.
Let's say that this data is saved in a file named \verb|mygraph|. 

The \matlab\ command \verb|load mygraph| reads the file \verb|mygraph|
and saves the contents of that file in a variable that is also named
\verb|mygraph|. (\matlab's current working directory must be the same
as the directory that contains the file \verb|mygraph|.)

The variable \verb|mygraph| is an $m\times 2$ array of edges. This can
be converted into a graph like this:
\begin{verbatim}
g = graph(mygraph)
\end{verbatim}
or if the graph \verb|g| already exists, like this:
\begin{verbatim}
resize(g,0)
add(g,mygraph)
\end{verbatim}
(The \verb|resize(g,0)| clears all data from \verb|g|.)

\matgraph\ also provides its own \verb|save| and \verb|load| commands.
\begin{itemize}
\item \verb|save(g,filename)| saves the graph \verb|g| to the user's
  hard drive in a file named in \verb|filename|. (For example,
  \verb|save(g,'mygraph')|.)  This saves all the information about the
  graph and not just a list of edges.
  
\item \verb|load(g,filename)| reads the graph data in the file named
  in \verb|filename| and sets \verb|g| to be that graph. The file
  named in \verb|filename| must be one created by \matgraph's
  \verb|save| command and \emph{not} just a list of edges. 
\end{itemize}


\matgraph\ provides a function named \verb|sgf| which stands for
\textbf simple \textbf graph \textbf format. This function converts
graphs to and from a 2-column matrix whose rows have the following
meanings:
\begin{itemize}
\item The first row is $[n~m]$ where $n$ is the number of vertices and
  $m$ is the number of edges in the graph.

\item The next $m$ rows give the edges of the graph; each row is of
  the form $[u~v]$ where $1 \le u\not=v \le n$.

\item Optionally, an additional $n$ rows give the locations of the
  vertices. Row number $m+1+i$ is $[x_i~y_i]$ and specifies the
  coordinates of vertex $i$. 
\end{itemize}
Matrices of this form are easy to read or to write on disk, and this
format is easy for other programs to produce. 


In addition, it is possible to create \verb|.m| files for saving
graphs to be used by other programs. For example, \matgraph's
\verb|dot| command writes graphs to disk in a format that can be
processed by GraphViz's \verb|dot| program. See also \verb|graffle|
and \verb|nauty|. 


\subsection{Handling large graphs}
\label{subsect:large}

Behind the scenes, graphs in \matgraph\ are saved as square matrices.
A graph with, say, ten thousand vertices would occupy an array with
100~million entries. \matlab\ provides the ability to handle matrices
large matrices with few nonzero entries efficiently. This ability is
embedded into \matgraph.

Small graphs are best handled using full storage. By default, a
graph created by \verb|g = graph| uses full storage. It is easy,
however, to convert a graph to use sparse storage.

\begin{itemize}
\item \verb|sparse(g)| converts a graph's storage method to be
  sparse. This is useful for extremely large graphs with relatively
  few edges (i.e., small average degree).

\item \verb|full(g)| converts a graph's storage to full mode. This is
  the preferred method for small graphs and graphs with many edges.
\end{itemize}

One can check the type of storage in use with the \verb|issparse| and
\verb|isfull| functions.

\smallbreak

The graph constructor \verb|g = graph| takes an optional argument; one
can write \verb|g = graph(n)| where \verb|n| is a nonnegative
integer. This creates a new graph with \verb|n| vertices. If \verb|n|
is small, full storage is used for \verb|g|. If \verb|n| is large,
sparse storage is automatically provided. How large is ``large''? See
\verb|set_large|. 


\subsection{Labels}

Naming vertices as consecutive integers from $1$ to $n$ can be
inconvenient. \matgraph\ provides a means to assign text labels to
vertices. The command \verb|label| can be used to assign such labels
to vertices: \verb|label(g,v,string)| assigns the characters in
\verb|string| to be a label for vertex \verb|v|. If a vertex of a
graph is deleted, all higher numbered vertices are renumbered, but
their labels are retained. The command \verb|get_label| is used to
learn the label of an individual vertex or to return a list of all
labels on all vertices  in a graph. See also \verb|clear_labels|.



\subsection{Visualization}

It is often useful to be able to see pictures of graphs. \matgraph\
provides a basic means to do this. 

One may associate an embedding with a graph; this is a mapping from
the vertex set to points in the plane.

The command \verb|draw| draws a picture of the graph in the plane by
placing each vertex at its $x,y$-coordinates and joining adjacent
vertices by line segments. See also \verb|ndraw| and \verb|ldraw|.
Note that \verb|draw| simply draws the graph in the current figure
window without erasing the contents of that figure; to see only the
graph, first give the \matlab\ command \verb|clf|. See also the
functions \verb|ndraw| and \verb|cdraw|. 

When \verb|draw| is invoked for graphs without embeddings, a default,
circular embedding is automatically constructed. Some graph building
operations attach an embedding to the graphs they form; for example,
\verb|petersen(g)| sets \verb|g| to be the Petersen graph with
vertices located at classic coordinates. 

It is possible to set a graph's embedding to coordinates of your
choosing with the \verb|embed| command. If \verb|g| has $n$ vertices
and \verb|xy| is an $n\times2$ matrix of real numbers, then
\verb|embed(g,xy)| sets the coordinates of the vertices to the
corresponding rows of \verb|xy|. The command \verb|randxy(g)| sets the
coordinates of the vertices to random locations. 

To learn the current embedding of a graph, use \verb|getxy(g)|. To
erase a graph's embedding, use \verb|rmxy(g)|. See also \verb|hasxy|.

The best \matgraph\ method to generate an embedding is
\verb|distxy|. This function uses \matlab's Optimization Toolbox. It
works reasonably well on small graphs. It attempts to place vertices
in the plane so that the Euclidean distance matches their
graph-theoretic distance, but the penalty is lessened the further
apart the nodes.


We also provide \verb|mdsxy| which creates an embedding based on
multidimensional scaling. It's fast, but produces mediocre results.



Readers are warmly encouraged to submit other embedding algorithms
for incorporation into \matgraph. 

\end{multicols}
\hrule
\begin{multicols}{2}[\section{Documentation}]
\label{sect:documentation}

This introduction to \matgraph\ does not list every function available
to the user. However, all functions (in \verb|.m| files) are
documented in the accompanying web pages.  These web pages are housed
in the \verb|html| subdirectory of the main \verb|matgraph| folder.
Double clicking on the file \verb|index.html| opens the main
documentation page in a web browser. From here, all the \verb|.m|
files can be found including descriptions, cross references, and
source code.  This includes the supporting classes \verb|partition|
and \verb|permutation|.


In addition, the user may get help on any \matgraph\ command with
\matlab's usual \verb|help| command. Some command names are
overloaded. For example, the name \verb|delete| is both a built-in
\matlab\ command and a \matgraph\ function. Type 
\verb|help graph/delete| to access the \matgraph\ version. 

For a list of all methods available for \verb|graph| objects, type
\verb|methods graph|.

See also \emph{Matgraph By Example} in the \verb|doc| directory.

The web pages in the \verb|html| directory were generated by by the
\verb|m2html| package created by Guillaume Flandin; this utility can
be found on the MathWorks' web site.





\end{multicols}\hrule
\begin{multicols}{2}[\section{The Permutation Class}]
\label{sect:perms}

Included in this toolbox is a class called \verb|permutation|. These
objects represent permutations of the integers $\{1,2,\ldots,n\}$.
Unlike \verb|graph|s, these object behave according to the usual
\matlab\ conventions and do not need to be specially
declared. \verb|permutation| objects are used by \matgraph's
\verb|renumber| command.

The standard way to build a permutation $p$ is to specify its action with
a vector of the form $[a_1,a_2,\ldots,a_n]$ where $a_i = p(i)$.  For
example:
\begin{verbatim}
>> p = permutation( [2 1 3 5 6 4] )
(1,2)(3)(4,5,6)
\end{verbatim}
This assigns to $p$ a permutation in which $p(1) =2$, $p(2) = 1$,
$p(3)=3$, $p(4)=5$, $p(5)=6$, and $p(6)=4$. Note that $p$ is displayed
on the console using the standard disjoint cycle notation.

The basic operations of applying a permutation to an element and
composition of permutations are implemented. Typing \verb|p(k)|
returns the action of the permutation $p$ on the element $k$. If $k$
is not in scope (outside the range $1$ to $n$), then $0$ is returned.
Composition of permutations is denoted by multiplication, \verb|*|.
Repeated composition can be achieved using the \verb|^| operator:
\verb|p^3| is equivalent to \verb|p*p*p|. The power may be zero or
negative.

Equality and inequality of permutations can be checked with \verb|==|
and \verb|~=|, respectively. 

Here are the functions defined for the class \verb|permutation|. Their
\verb|.m| files are found in the \verb|@@permutation| folder.

\begin{itemize}
\item \verb|array|: convert a permutation to an array. The syntax is
  \verb|array(p)|. This returns a $1 \times n$ array whose
  $i^{\text{th}}$ entry if $p(i)$. For example, if
  $p=(1,2)(3)(4,5,6)$, then \verb|array(p)| returns
  the array $[2 ,1 ,3 ,5 ,6 ,4]$. 

\item \verb|cycles|: determine  the cycle structure of a
  permutation. The syntax is \verb|cycles(p)|. This returns a cell
  array. Each member of the cell array contains the elements (in
  order) of a cycle of $p$. For example, if $p=(1,2)(3)(4,5,6)$, then 
  \verb|c=cycles(p)| sets \verb|c{1}| to $[1,2]$, \verb|c{2}| to
  $[3]$, and \verb|c{3}| to $[4,5,6]$. 

\item \verb|inv|: permutation inverse. The syntax is
  \verb|inv(p)|. This returns the inverse permutation,  $p^{-1}$. 

\item \verb|length|: number of elements permuted. The syntax is
  \verb|length(p)|. For example, if $p=(1,2)(3)(4,5,6)$, then
  \verb|length(p)| is $6$. 
  
\item \verb|matrix|: return a permutation matrix that represents the
  permutation. The syntax is \verb|matrix(p)|. For example, if
  $p=(1,2)(3)(4,5,6)$, then \verb|matrix(p)| gives this:
\begin{verbatim}
     0     1     0     0     0     0
     1     0     0     0     0     0
     0     0     1     0     0     0
     0     0     0     0     0     1
     0     0     0     1     0     0
     0     0     0     0     1     0
\end{verbatim}


\item \verb|permutation|: class constructor. This can be called two
  ways. If $n$ is a positive integer, \verb|permutation(n)| returns
  the identity permutation on $\{1,2,\ldots,n\}$. If $x$ is an array
  containing the elements $1$ through $n$, then \verb|permutation(x)|
  creates the permutation specified by those elements. For example, if
  $x$ is \verb|[2 1 3 5 6 4]|, then \verb|permutation(x)| gives the
  permutation $(1,2)(3)(4,5,6)$.

  
\item \verb|random|: shuffle a permutation. The syntax is
  \verb|random(p)|. This returns a permutation on the same elements as
  $p$ but in a random order.  Typically, to generate a random
  permutation on $n$ elements, one would type this:
  \verb|random(permutation(n))|.

\item \verb|sign|: sign (parity) of a permutation. The syntax is
  \verb|sign(p)|. This returns $1$ is $p$ is an even permutation and
  $-1$ is $p$ is an odd permutation.

\item \verb|size|: give the number of elements and number of cycles in
  a permutation. The syntax is \verb|size(p)|. This returns a
  two-element array. The first element is the number of objects
  permuted by the permutation and the second element is the number of
  cycles in the disjoint-cycle representation of $p$. 
  
  \matlab\ uses this when reporting on permutation variables in the
  workspace. The permutation $(1,2)(3)(4,5,6)$ is described as a
  \verb|<6x3 permutation>|. The $6$ refers to the fact that this is a
  permutation of the set $\{1,2,\ldots,6\}$ and the $3$ refers to the
  fact that this permutation has $3$ cycles. 
\end{itemize}

\end{multicols}\hrule
\begin{multicols}{2}[\section{The Partition Class}]
\label{sect:partition}
The \verb|partition| class represents partitions of sets of the form
$\{1,2,\ldots,n\}$. A partition can be created with the command
\verb|p=partition(n)|. This creates a partition in which all parts
have size $1$; that is, the partition
$\bigl\{\{1\},\{2\},\ldots,\{n\}\bigr\}$. A partition can also be
created from a cell array. Each cell in the array should list the
elements of a block; the integers $1$ through $n$ should appear
exactly once in each member of the cell array. For example, if we type
\begin{verbatim}
c = {[1 2 4],[3 5 6],[7:10]};
p = partition(c)
\end{verbatim}
Then $p$ is the partition
$\bigl\{\{1,2,4\},\{3,5,6\},\{7,8,9,10\}\bigr\}$ and \matlab\ types
this:
\begin{verbatim}
{ {1,2,4} {3,5,6} {7,8,9,10} }
\end{verbatim}

If $p$ is a partition and $k$ is an integer, the expression
\verb|p(k)| returns the elements in the same part as $k$. For the
partition presented above, \verb|p(2)| would return the array
\verb|[1 2 4]|.  For integers $j$ and $k$, the expression
\verb|p(j,k)| returns true if $j$ and $k$ are in the same part of $p$
and false otherwise.

The meet and join of two partitions is computed using \verb|p*q| and
\verb|p+q|, respectively. Equality and inequality can be checked with
\verb|==| and \verb|~=|.

Partitions can be converted into cell arrays with the \verb|parts|
function. 

Here is a list of the various functions defined for the
\verb|partition| class; these can be found in the \verb|@@partition|
folder.

\begin{itemize}

\item \verb|merge|: combine two parts. The syntax is
  \verb|merge(p,j,k)|. This returns a new partition in which the parts
  containing $j$ and $k$ have been merged into a single part. 


\item \verb|np|: number of parts. The syntax is \verb|np(p)|; the
  number of parts in the partition is returned.

\item \verb|nv|: size of the ground set. The syntax is \verb|nv(p)|;
  the number of elements in the ground set of the partition is
  returned. 
  
\item \verb|partition|: constructor for this type. The simple syntax
  is \verb|partition(n)| (where $n$ is a positive integer). This
  builds a partition with ground set $\{1,2,\ldots,n\}$ in which there
  are $n$ parts (all of size one).

  Alternatively, if $c$ is a cell array, then \verb|partition(c)|
  creates a partition based on the arrays in $c$. Each of \verb|c{1}|,
  \verb|c{2}|, and so on, is a list of integers. Together, these lists
  should contain each of the integers in $[n]$ exactly once.

\item \verb|parts|: get the parts of the partition. The syntax is
  \verb|parts(p)|. This returns a cell array. Each cell contains a
  list (vector) of positive integers in one of the parts of $p$. 



\item \verb|size|: report the number of elements in the ground set and
  the number of parts. The syntax is \verb|size(p)|. This returns a
  $1\times2$ array \verb|[n m]| where $n$ is the size of the ground
  set and $m$ is the number of blocks. 

  This is used by \matlab\ when it reports the variables in a
  workspace. A partition is reported like this:
  \verb|<10x3 partition>|. This means the partition's ground set is
  $[10]$ and there are three parts in the partition. 


\end{itemize}


\end{multicols}
\hrule
\begin{multicols}{2}[\section{Under the Hood (Stuff You Don't Need to Know)}]
\label{sect:under-the-hood}


All data about graphs are held in a hidden global data structure named
\verb|GRAPH_MAGIC|. Objects of type \verb|graph| are simply indices
into this structure. This enable us to simulate call-by-reference
semantics for \emph{graph} objects; that is, \matlab\ functions can
modify \emph{graph} arguments. 

It is possible to save the entire \verb|GRAPH_MAGIC| structure into
another variable; this would allow multiple ``graph theory universes''
to coexist. It's not clear this is needed.

\subsection{The \texttt{GRAPH\_MAGIC} structure}

The global data structure is named \verb|GRAPH_MAGIC|. To access this
structure directly, use the following line in your \verb|.m| files:
\begin{verbatim}
global GRAPH_MAGIC
\end{verbatim}

The \verb|GRAPH_MAGIC| structure contains the following fields:
\begin{itemize}
\item \verb|ngraphs|: the number of ``slots'' available in this
  structure (equal to the size of the arrays \verb|GRAPH_MAGIC.graphs|
  and \verb|GRAPH_MAGIC.in_use|).

\item \verb|graphs|: this is a cell array containing the graphs. (See
 \S\ref{inside-GM.g}.)


\item \verb|in_use|: an array that indicates which slots are taken. A
  $1$ in position $i$ of this array signals that slot $i$ is taken; a
  $0$ means the slot is available to hold a new graph.

\item \verb|Q|: a structure implementing a double-ended queue. (See \S\ref{Q}.)

\item \verb|large_size|: a variable holding the cutoff between
  ``large'' and ``small'' graphs. If the graph constructor
  \verb|graph| is fed a large argument, it creates a sparse graph. 
\end{itemize}

\subsubsection{Inside \texttt{GRAPH\_MAGIC.graphs}}
\label{inside-GM.g}

The cell array \verb|GRAPH_MAGIC.graphs|  holds the graphs. Each cell in
this array is a structure with two fields: \verb|array| and
\verb|xy|. The \verb|array| field holds the adjacency matrix of the
graph (a zero-one, symmetric matrix). The \verb|xy| field holds the
embedding for the graph; this is an $n\times 2$ array of real values
giving the coordinates of the vertices.


\subsubsection{The private double-ended queue}
\label{Q}

The \verb|Q| field of \verb|GRAPH_MAGIC| is a double-ended queue
available for use by \verb|graph| algorithms (e.g.,
\verb|bfstree|). It is a structure that contains three fields:
\begin{itemize}
\item \verb|array|: a one-dimensional array that holds the stack/queue
  values.
\item \verb|first|: an index pointing to the first (front most) element
  of the queue.
\item \verb|last|: an index pointing to the last (back most) element of
  the queue.
\end{itemize}

There is a small suite of tools for working with the queue in the
directory \verb|@@graph/private|. These are visible to functions inside
the \verb|@@graph| directory, but not generally available. Here they
are (in alphabetical order):

\begin{itemize}
\item \verb|q_capacity|: gives the maximum capacity of the queue.

\item \verb|q_get|: returns a list of the elements in the queue (that
  is, \verb|array(first:last)|).

\item \verb|q_init|: called with one argument, this initializes the queue
  with a given capacity.

\item \verb|q_pop_back|: pops off (and returns) the last element of
  the queue. This is a stack-like operation.

\item \verb|q_pop_front|: pops off (and returns) the front most element in the
  queue. This is a queue-like operation.

\item \verb|q_push|: called with one argument, this adds an element to
  the back of the queue.

\item \verb|q_size|: returns the number of elements in the queue. 
\end{itemize}


\subsection{The \texttt{graph} type}

The \emph{graph} type is simply a ``wrapper'' for an integer; that
integer is an index into the \verb|GRAPH_MAGIC.graphs| array.  A
\emph{graph} object contains just one field, \verb|idx|, which holds
that integer.

In many \emph{graph} functions (in the \verb|@@graph| directory) we see
the following:
\begin{verbatim}
GRAPH_MAGIC.graphs{g.idx}.array
\end{verbatim}
This is how we refer to the adjacency matrix of the graph \verb|g|.

\end{multicols}
\hrule
\begin{multicols}{2}[\section{Future Projects}]

There are many additions I would like for this project. Here are
few:
\begin{itemize}
\item Planarity testing and embedding. I would like an \verb|is_planar|
  method to test if a graph is planar and a good \verb|planar_embed|
  method for finding a crossing-free embedding.

\item The \verb|distxy| layout routine works reasonably well, but is
  hardly fast. It also relies on the  Optimization Toolbox. I'd like a
  better layout engine.

\item A GUI for creating and editing graphs. I'd like to see this
  invoked with a command such as \verb|gui(g)| or
  \verb|graph_edit(g)|.
  
\item We need \verb|.m| files for connectivity, edge connectivity,
  maximum matching (in general graphs), approximate
  isomorphism, better heuristic coloring algorithms, girth, and so
  forth.
\end{itemize}

\end{multicols}
\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
@


1.29
log
@*** empty log message ***
@
text
@d566 2
a567 1
processed by GraphViz's \verb|dot| program. See also \verb|graffle|. 
d632 2
a633 1
graph, first give the \matlab\ command \verb|clf|.
d651 12
a662 13
Two \matgraph\ methods are provided to calculate embeddings based on
the graph's structure: \verb|springxy| and \verb|distxy|. Both of
these require \matlab's Optimization Toolbox and are only useful for
small graphs. Both use the graph's current embedding as a starting point
for an optimal embedding (but with different objective functions for
the two methods). 

\verb|springxy| finds an embedding by modeling vertices as repelling
objects with edges acting as springs that attract the nodes they join.
\verb|distxy| attempts to place vertices in the plane so that their
Euclidean distance matches their graph theoretic distances; greater
emphasis is given to vertices at smaller distances. Of these,
\verb|distxy| runs faster and gives reasonable results.
d1012 3
a1014 3
\item The current \verb|springxy| routine is extremely slow and gives lousy
  results. The newer \verb|distxy| is better, but  hardly fast. Both
  rely on the Optimization Toolbox. I'd like a better layout engine.
d1021 1
a1021 1
  maximum matching (in general graphs), isomorphism, approximate
@


1.28
log
@*** empty log message ***
@
text
@d691 5
a695 3
The web pages were generated by by the \verb|m2html| package created
by Guillaume Flandin; this utility can be found on the MathWorks' web
site.
d1018 1
a1018 1

d1021 2
a1022 2
  isomorphism, better coloring algorithms, Hamiltonian cycles, girth,
  and so forth.
@


1.27
log
@*** empty log message ***
@
text
@d553 1
a553 1
  the form $[u v]$ where $1 \le u\not=v \le n$.
@


1.26
log
@*** empty log message ***
@
text
@d543 20
d566 1
a566 1
processed by GraphViz's \verb|dot| program. 
@


1.25
log
@*** empty log message ***
@
text
@d9 1
a9 1
\title[Matgraph]{MATGRAPH: A MATLAB Package for Graph Theory}
d45 1
a45 1
In addition to providing a natural \verb|graph| class, \matgraph\ also
d70 3
a72 3
(where \verb|X.X| is replaced by the correct version number) to
unpack. On other computers, double clicking on the file's icon should
serve the same purpose.
d110 1
a110 1
  distinct vertices either are not adjacent or else are joined by a
d298 3
a300 3

  Remember: The vertex set of all graphs in \matgraph\ are of the form
  $\{1,2,\ldots,n\}$ where $n\ge0$. 
d321 1
a321 1
    and then vertices are renamed to the vertex set remains of the
d391 1
a391 1
old. For example, \verb|line_graph(h,g)| set \verb|h| to be the line
d395 3
a397 3
  incident with a common vertex.}  Other operations include
\verb|cartesian|, \verb|complement|, \verb|mycielski|, \verb|induce|,
\verb|intersect|, \verb|union|, and \verb|trim|.
d495 1
a495 1
$x^5-5x^4+10x^3-10x^2+4x$. 
d502 1
a502 1
\matgraph\ can read and write graphs to files on the user's hard
d577 1
a577 1
can also write \verb|g = graph(n)| where \verb|n| is a nonnegative
d632 1
a632 1
small graphs. Both use the graph's current embedding as starting points
d634 8
a641 7
the two functions). \verb|springxy| finds an embedding by modeling
vertices as repelling objects with edges acting as springs that
attract the nodes they join. \verb|distxy| attempts to place vertices
in the plane so that their Euclidean distance matches their graph
theoretic distances; greater emphasis is given to vertices at smaller
distances. Of these, \verb|distxy| runs faster and gives reasonable
results. 
d710 3
a729 8
\item \verb|display|: display a permutation on the console. This is
  used by \matlab\ to write a permutation onto the
  console. Permutations are written in disjoint cycle form. 


\item \verb|eq|: test permutations for equality. The syntax is
  \verb|p==q|. 

a748 11
\item \verb|mpower|: repeated composition. The syntax is \verb|p^k|
  where $p$ is a permutation and $k$ is an integer. If $k$ is
  positive, this gives the repeated composition $p\circ
  p\circ\cdots\circ p$. If $k$ is zero, the identity permutation is
  returned. If $k$ is negative, then the appropriate power of $p$'s
  inverse is returned. 

\item \verb|mtimes|: composition. The syntax is \verb|p*q| where $p$ and
  $q$ are permutations.

\item \verb|ne|: test of inequality. The syntax is \verb|p~=q|.
a779 6

\item \verb|subsref|: implement the syntax \verb|p(k)|. This returns
  the action of the permutation $p$ on the integer $k$. If $k$ is out
  of range (less than $1$ or greater than \verb|length(p)|), then $0$
  is returned. 

d786 1
a786 1
$[n] = \{1,2,\ldots,n\}$. A partition can be created with the command
d812 2
a813 1
\verb|p+q|, respectively. 
a822 8
\item \verb|check|: check the internal data structure of a
  partition. This is used by other functions in this class; there is
  little need for an ordinary user to invoke this method.

\item \verb|display|: used by \matlab\ when a partition needs to be
  printed to the console. 

\item \verb|eq|: check for equality. The syntax is \verb|p == q|. 
a827 3
\item \verb|mtimes|: meet to two partitions. The syntax is \verb|p*q|.

\item \verb|ne|: check for inequality. The syntax is \verb|p ~= q|. 
d835 1
a835 1

d838 2
a839 2
  builds a partition with ground set $[n]$ in which there are $n$
  parts (all of size one). 
a849 1
\item \verb|plus|: join of partitions. The syntax is \verb|p+q|. 
a861 4
\item \verb|subsref|: implement subscripting notations. The syntax
  \verb|p(k)| returns a list of elements in the same part of $p$ as
  $k$. The syntax \verb|p(j,k)| returns true if $j$ and $k$ are in the
  same part and false otherwise.
d868 1
a868 1
\begin{multicols}{2}[\section{Under the Hood}]
d871 1
d982 1
a982 1
There are many additions I would like to see to this project. Here are
@


1.24
log
@*** empty log message ***
@
text
@d1 2
a2 2
\documentclass[12pt]{amsart}
\usepackage[margin=1in]{geometry}
d7 1
a7 1

a22 1

d29 1
a29 1
\section*{Overview}
d31 1
a31 1
Matgraph is a toolbox for working with simple\footnote{Simple graphs
d50 3
a52 1
\section{Getting \matgraph}
d96 3
a98 2

\section{Using \matgraph}
d110 1
a110 1
  distinct vertices are either not adjacent or else are joined by a
d128 2
a129 2
  \verb|func.m|. In \matlab, issuing the command \verb|func(A)| never
  changes the value held in the variable \verb|A|.
d140 1
a140 1
  \emph{first} argument to the function. For example, \verb|matgraph|
d196 1
a196 1
If you ever wish to clear out the all of the hidden data structures
d204 1
a204 1
  view that function's documentation with a web browser or using
d250 5
a254 5
\verb|graph| variable temporarily. {\bfseries Every graph that is created using
the \verb|g = graph| constructor must be released by a matching call to 
\verb|free(g)|.} Otherwise, each time the function is invoked, another
slot in \matgraph's hidden data structure is consumed until no slots
remain available. 
d286 7
a292 7

  An way to use  \verb|add| is like this: \verb|add(g,elist)| where
  \verb|elist| is a $k\times 2$ array of positive integers. Each row
  of \verb|elist| is considered an edge, and all of these edges are
  added to the graph. If any end point of any edge is larger than the
  number of vertices currently in the graph, the graph is resized to
  accommodate.
d324 1
a324 1
    For example, if \verb|g| is the cycle on 5 vertices with edges
d328 1
a328 1
    3, so the final result is the path $3 \sim 1 \sim 2$.
d330 1
a330 1
  \item \verb|delete(g,u,v)| deletes the edges between \verb|u| and
d357 1
a357 1
\matgraph\ provides a host of functions for forming standard
d409 5
a413 5
There are two ways to see if an edge is present in a graph
\verb|g|. The command \verb|has(g,u,v)| returns $1$ (for true) if the
edge between \verb|u| and \verb|v| is present in \verb|g|, and $0$
otherwise. Alternatively, the exact same exact result is produced by
\verb|g(u,v)|. 
d425 1
a425 1
exists, and empty array is returned. 
d480 1
a480 1
sets by greedy coloring algorithm (step through the vertices in
d552 5
a556 5
Behind the scenes, graphs in \matgraph\ are saved as square
matrices. A graph with, say, ten thousand vertices would occupy an
array with 100~million entries. \matlab\ provides the ability to save
matrices large matrices with few nonzero---sparse matrices---entries
efficiently. This ability is embedded into \matgraph.
d632 1
a632 1
small graphs. Both use the graphs current embedding as starting points
d645 3
a647 9








\section{Documentation}
d671 1
a671 1
by Guillaume Flandin; this utility can be found on the MathWorks web
d678 2
a679 3


\section{The Permutation Class}
d683 1
a683 1
objects represent permutations of the integer $\{1,2,\ldots,n\}$.
d706 1
a706 1
\verb|p^3| is equivalent to $p*p*p$. The power may be zero or
d709 2
a710 2
Here are the functions defined for the class \verb|permutation|. These
functions are found in the \verb|@@permutation| folder.
d803 2
a804 1
\section{The Partition Class}
d827 1
a827 1
permutation presented above, \verb|p(2)| would return the array
d902 3
a904 2

\section{Under the Hood}
d949 1
a949 1
The \verb|GRAPH_MAGIC.graphs| cell array holds the graph. Each cell in
d1011 1
a1011 1
This is how we refer to the adjacency matrix of the graph $g$.
d1013 3
a1015 1
\section{Future Projects}
d1020 1
a1020 1
\item Planarity testing and embedding. I would like a \verb|is_planar|
d1026 1
a1026 1
  rely on the optimization toolbox. I'd like a better layout engine.
d1038 1
a1038 1

@


1.23
log
@*** empty log message ***
@
text
@d30 1
a30 1

d47 3
a49 3
defines helper classes \verb|permutation|
(see~\S\ref{sect:perms}) and \verb|partition|
(see~\S\ref{sect:partition}
d82 2
a83 2
free of charge under the GNU General Purpose Licences. A copy of this
licence can be found at
d123 1
a123 1
  Most \matlab\ functions use \emph{call by value} symantics. That is,
d130 1
a130 1
  type \verb|graph| use \emph{call by reference} symantics. This means
d200 4
a203 1
  the web-based information on all \matgraph\ functions.}  the
d229 1
a229 1
Behind the scences, one of the ``slots'' allocated for graphs (by
d238 1
a238 1
If, inadvertantly, a \verb|graph| variable is cleared from \matlab's
d290 1
a290 1
  accomodate.
d380 4
a383 2
Various random graphs can be built using \verb|random|,
\verb|random_bipartite|, \verb|random_regular|, and \verb|sprandom|.
d447 1
a447 1
following commmand returns the eigenvalues of (the adjacency matrix
d483 1
a483 1
The chromatic polynonmial of a graph can be found for small
d612 1
a612 1
circular embeddding is automatically constructed. Some graph building
d674 4
d707 1
a707 1
returns the action of the permtuation $p$ on the element $k$. If $k$
d778 1
a778 1

d781 3
a783 4
  $p$ but in a random order. 

  Typically, to make a random permutation on $n$ elements, one would
  type this: \verb|random(permutation(n))|. 
d969 1
a969 1
\item \verb|first|: an index pointing to the first (frontmost) element
d971 1
a971 1
\item \verb|last|: an index pointing to the last (backmost) element of
d992 1
a992 1
\item \verb|q_pop_front|: pops off (and returns) the frontmost element in the
@


1.22
log
@*** empty log message ***
@
text
@d16 2
a17 1
\newcommand\matlab{\textsc{Matlab}}
a29 4
\noindent
\emph{Note:} I'm behind on maintaining this document. New methods have
been added to Matgraph since this has been updated. See the web pages
accompanying this distribution. 
d31 119
a149 1
For the latest version of Matgraph, see the following URL:
d151 1
a151 1
http://www.ams.jhu.edu/~ers/matgraph/
d153 2
d156 1
a157 1
\section{Introduction}
a158 4
Matgraph is a toolbox for working with simple\footnote{Simple graphs
  are undirected graphs without loops or multiple edges.} graphs in
\matlab. The goal is to make interactive graph theory exploration
simple and efficient. 
a159 3
To this end, we have created a \matlab\ type called
\emph{graph}. Objects of type \emph{graph} can be used (almost) as
easily as matrices. 
d161 2
d164 8
a171 1
\subsection{Installation}
d173 8
a180 3
Copy the \verb|matgraph| folder to your hard drive. Then launch
\matlab\ and be sure that the \verb|matgraph| directory is visible to
\matlab\ using \matlab's \verb|path| command, like this:
d182 1
a182 1
addpath /home/myname/programming/matlab/matgraph
d184 25
a210 1
\subsection{Objects of type \emph{graph}}
d223 5
d229 3
a231 5
In any given \matlab\ session, the first time you type \verb|g=graph|
an invisible data structure is created to hold your graphs. This data
structure is set to hold 100 graphs. If you expect that you will need
to deal with more than 100 graphs, you can initialize the system to
hold a larger number using the \verb|graph_init| command like this:
d233 1
a233 2
graph_init(1000);
g = graph;
d235 2
a236 118
Note that some of the functions create auxilliary graphs during their
execution. These are released before the function exits, but if there
are no slots available, the functions will not work. 

The graph $g$ is actually a reference into the hidden data
structure. If you were now to type \verb|h = g;| the variable $h$
would refer to exactly the same graph.  That is, any modification you
make to $g$ would also modify $h$. It is unlikely that this is what
you want to do. If you want to make an independent copy of $g$, you
need to do this:
\begin{verbatim}
h = graph;    % h is a new graph, different from g
copy(h,g);    % h is now a clone of g
\end{verbatim}
Now if you modify $g$, those modifications are not reflected in $h$.

Every time you use the \verb|graph| contructor method, one of the
slots in the hidden graph repository is consumed. When you no longer
need a graph, you can release its hold on one of the slots with the
\verb|free| command, like this:
\begin{verbatim}
free(g);
\end{verbatim}
This is especially important if you write your own functions that use
temporary graph variables. If each construction \verb|g=graph| is
balanced by a subsequent \verb|free(g)|, all should be well. 

Note that \matlab's \verb|clear| should not be used on a \emph{graph}
variable before it is \verb|free|'d; otherwise, the slot occupied by
the variable in the hidden graph system is not released and there is
no convenient way to recover that slot. 

To free all graphs, use the command \verb|free_all|. To eradicate the
hidden data structure holding the graphs, use \verb|graph_destroy|. 


\subsection{Working with graphs}

Matgraph includes several methods for building graphs. Once a graph
variable is declared (via \verb|g=graph|), it is possible to add or
delete vertices and/or edges, or use specific construction methods. 

Keep in mind the following two important principles when working with
graphs in Matgraph.

\begin{enumerate}
\item The vertex set of the graphs \emph{always} consists of
  consecutive integers beginning with $1$. 

\item The first argument in a graph method is considered to be the
  ``direct object'' of the method. Matgraph methods are able to modify
  their arguments; if a graph is modified by a method, only the
  first argument is modified. 
\end{enumerate}

When a graph is first declared, it contains no vertices or edges (the
empty graph).\footnote{An optional argument to \texttt{graph} can be
  used to declare graphs with a specified number of vertices already inserted.}

The \verb|resize| command can be used to add (or delete) vertices from
the graph: \verb|resize(g,n)|. If $g$ initially has $k$ vertices and
$n>k$, then new vertices named $k+1$ through $n$ are added; the rest
of the graph is unaffected. However, if $n<k$, then vertices $n+1$
through $k$ are deleted from $g$, but the rest of the graph is
unaffected.

Edges can be added to the graph with the \verb|add| method:
\verb|add(g,u,v)| adds the edge $uv$ to $g$. If either $u$ or $v$
exceeds the number of vertices in the graph, extra vertices are added
to the graph. If $u=v$ or either is nonpositive, no action is taken.

Vertices or edges can be deleted from a graph with the \verb|delete|
command. The command \verb|delete(g,u)| deletes vertex $u$ from $g$;
all vertices with labels greater than $u$ are renumbered [see
principle~(1) above].  The command \verb|delete(g,u,v)| deletes the
edge $uv$ from $g$ (assuming such an edge is present).

A variety of handy methods are available to create common types of
graphs including complete and complete multipartite graphs, paths,
grids, random graphs, line graphs, interval graphs, etc. There are
also methods for generating spanning trees and induced subgraphs. 

To learn the number of vertices and edges, see the \verb|nv|,
\verb|ne|, and \verb|size| commands. To learn the full set of edges in
$g$, use \verb|edges(g)|. 


\subsection{Vertex labels}

It is possible to assign character string labels to the vertices of
graphs. The labels are distinct from the vertex numbers that are used
in the graph methods. The command \verb|label(g)| assigns default
labels to the vertices and \verb|label(g,v,str)| labels vertex $v$
with the string in \verb|str|. Use \verb|get_label(g,v)| to learn a
vertex's label and \verb|get_label(g)| to fetch all labels as a cell
array. See also \verb|is_labeled| and \verb|clear_labels|.


\subsection{Storage class}

\matlab\ stores matrices in one of two ways: \emph{full} or
\emph{sparse}.  The size (in memory) of a full matrix is proportional
to the number of entries in the matrix. The size of a sparse matrix is
proportional to the number of nonzero entries. Sparse matrices offer
important memory savings for large matrices with relatively few
nonzero entries. 

Matgraph allows you to specify the type of storage used for your
graphs. The commands \verb|full(g)| and \verb|sparse(g)| convert the
graph to the respective storage type. The queries \verb|isfull(g)| and
\verb|issparse(g)| are used to learn the type of storage used for the
specified graph. 

When a graph is declared with a specific number of vertices (e.g.,
\verb|g=graph(2000)|), Matgraph picks a default storage type. The
cutoff between full and sparse can be set using the command
\verb|set_large|. 

d238 4
a241 2
\section{Functions, Methods, and Operators}
\label{sect:reference}
d243 7
a249 9
\subsection{Graph methods}
This is an alphabetical list of the methods for the \verb|graph|
class. Items marked with a solid bullet $\bullet$ do not modify their
arguments, but items marked with an open circle $\circ$ may modify the
graph appearing as the first argument (or may modify the graph's
embedding).  In all cases, graphs that are not the first argument are
not modified. Based on this principle, it is easy to deduce that
\verb|copy(g,h)| overwrites $g$ with a copy of $h$, and not vice
versa.
d251 2
a253 73
\begin{itemize}

\item \verb|across|: find edges between disjoint sets of vertices. The
  syntax is \verb|across(g,X,Y)|. This returns a two-column list of
  edges of $g$ with one end in $X$ and one end in $Y$. We assume
  $X\cap Y = \emptyset$ but do not assume $X \cup Y = V(g)$. In case
  the second argument is omitted, we take $Y=V(g)-X$.

\oitem \verb|add|: add edge(s) to a graph. The basic syntax is
  \verb|add_edge(g,u,v)|. This form adds the edge $uv$ to the graph
  $g$. Note that if $u=v$ or if either $u$ or $v$ is nonpositive then no
  edge is added (and no warning is given).  If either is greater than
  the number of vertices in the graph, extra vertices are added. 

  An alternative syntax is \verb|add(elist)| where \verb|elist| is an
  $m\times2$ list of edges. This adds all the edges in the list to the
  graph.


\item \verb|alpha|: independence number of a graph. Calling
  \verb|alpha(g)| returns the maximum size of an independent set in
  the graph $g$. Calling \verb|[a,S]=alpha(g)| returns $\alpha(g)$ in
  $a$ and a maximum size independent set in $S$.

  Note: This method uses integer programming; hence it requires
  \matlab's optimization toolbox and may run slowly (if at all) for
  large graphs. 
  
\oitem \verb|bfstree|: breadth-first spanning tree. The syntax is
  \verb|bfstree(t,g,v)|. This overwrites $t$ with the breadth-first
  spanning tree of $g$ rooted at $v$. If $g$ is not connected, the
  tree spans only the vertices in $v$'s components; the other vertices
  appear as isolates in $t$. If the third argument, \verb|v|, is
  omitted, vertex $1$ is used.


\item \verb|bipartition|: find a bipartition of a bipartite
  graph. This is the 
  syntax: 
\begin{verbatim}
parts = bipartition(g)
\end{verbatim}
  If $g$ is a bipartite graph, this returns a partition object (see
  Section~\ref{sect:partition}) containing the disjoint subsets $X$
  and $Y$ of $V(g)$ so that $X,Y$ is a bipartition ($2$-coloring) of
  $g$.

  If $g$ is not bipartite, this returns an empty partition.

\item \verb|bipmatch|: find maximum matching in a bipartite
  graph. There is a choice of syntax. One may either call
  \verb|bipmatch(g,X,Y)| where $X$ and $Y$ are disjoint subsets of
  $V(g)$, or \verb|bipmatch(g,p)| where $p$ is a partition object (see
  Section~\ref{sect:partition}) with exactly two parts: $X$ and $Y$.
  
  This function finds a maximum matching on the bipartite (sub)graph
  of $g$ with bipartition $X \cup Y$. This function returns an
  $m\times2$ list of the edges in a maximum matching.
  
\oitem \verb|cartesian|: Cartesian products of graphs. The syntax is
  \verb|cartesian(g,h,k)|. This overwrites $g$ with the Cartesian
  product $h \times k$. 

  If both $h$ and $k$ have embeddings, an embedding is created for
  $g$ as follows. The vertex $(v,w)$ in the product is first embedded in
  $\RR^4$ by concatenating the coordinates of $v$ with the coordinates
  of $w$. Then we select a random projection $p:\RR^4\to\RR^2$ and
  apply $p$ to all vertices of the product. 

\item \verb|chromatic_poly|: compute the chromatic polynomial of a
  graph. The syntax is \verb|chromatic_poly(g)|. This returns the
  chromatic polynomial of the graph $g$. The algorithm is terribly
  slow, so this is useful only for graphs with very few edges. 
a254 5
\oitem \verb|clear_edges|: delete all edges from a graph. The syntax is
  \verb|clear_edges(g)|. 
  
\oitem \verb|clear_labels|: delete all labels on verticeds. The syntax
is \verb|clear_labels(g)|.
a255 4
\item \verb|color|: vertex coloring of the graph. The syntax is
  \verb|color(g)| or \verb|color(g,algo)| where \verb|algo| is a
  string specifying the algorithm to use. At present the only
  algorithm (and the default) is \verb|'greedy'|.
d257 1
a257 4
  This partitions the vertex set of $g$ into independent sets; that
  is, we find a proper coloring of the graph. Because graph coloring
  is \textsc{np}-hard, the coloring found might not be best possible. 
  The coloring is returned as a partition of the vertex set, $[n]$. 
d259 5
a263 4
  The greedy algorithm works as follows. First, we sort the vertices
  by degree (largest to smallest). We then color the vertices in this
  order giving to each vertex the smallest color not yet seen on its
  neighbors. 
d265 28
a292 1
  We hope to add other coloring algorithms in the future.
d294 2
a296 3
\oitem \verb|cube|: create a hypercube graph. The syntax is
  \verb|cube(g,k)|. This overwrites $g$ with a $k$-cube; that is, a
  $k$-fold Cartesian product of $K_2$ with itself. 
d298 2
a299 2
  If the second argument is omitted, we assum $k=3$ and give the graph
  a nice planar embedding. 
a300 6
\oitem \verb|complement|: convert a graph to its complement. The syntax
  is \verb|complement(g)|. This overwrites $g$ with $\overline{g}$.


\oitem \verb|complete|: form complete, complete bipartite, and complete
  multipartite graphs. Here are the various syntaxes:
d302 22
a323 6
  \item \verb|complete(g)|: overwrite $g$ with $K_n$ where $n$ is the
    number of vertices in $g$.
  \item \verb|complete(g,n)|: when $n$ is an integer, overwrite $g$
    with $K_n$.
  \item \verb|complete(g,n,m)|: when $n,m$ are integers, overwrite $g$
    with $K_{a,b}$. 
d325 8
a332 7
  \item \verb|complete(g,list)|: where \verb|list| is a 1-dimensional
    array containing the integers $n_1,n_2,\ldots,n_p$, overwrite $g$
    with the complete multipartite graph $K(n_1,n_2,\ldots,n_p)$. Here
    $p$ must be at least $2$ or else a complete graph on $n_1$
    vertices is generated.
  \end{itemize} % end complete

d334 5
a338 20
\item \verb|components|: find the connected components of a graph.
  If $g$ is a graph on $n$ vertices, the command \verb|components(g)|
  returns an $n$-long vector whose $i^{\text{th}}$ entry is the
  component of vertex $i$.  To find the number of connected components
  in a graph, use \verb|max(components(g))|.

\oitem \verb|contract|: contract an edge. The syntax is
  \verb|contract(g,u,v)|. The action is to add all of $v$'s neighbors
  to $u$'s neighborhood and then delete $v$.

\oitem \verb|copy|: clone a graph. The syntax is \verb|copy(g,h)|. This
  overwrites $g$ with a copy of $h$.  Note this is different from
  \verb|g=h)| which makes $g$ a handle to the same graph object
  as $h$ (so changes to $h$ affect $g$). It is similar to 
  \verb|g=graph(h)| which makes an independent copy of $h$, but also
  grabs a new slot for $g$. 

\oitem \verb|cycle|: create a cycle graph. The syntax is
  \verb|cycle(g,n)|. This overwrites $g$ with the $n$-cycle, $C_n$. A
  circular embedding is provided.
d340 2
d343 1
a343 6
\item \verb|deg|: degree of a vertex or degree sequence. The syntaxes
  are as follows:
  \begin{itemize}
  \item \verb|deg(g)|: returns the degree sequence of $g$.
  \item \verb|deg(g,v)|: returns the degree of vertex $v$ in graph $g$.
  \end{itemize}
d346 2
a348 14
\oitem \verb|delete|: delete vertices/edges from the graph. The action
  of \verb|delete| depends on the syntax:
  \begin{itemize}
  \item \verb|delete(g,v)|: delete a single vertex $v$ from $g$.
  \item \verb|delete(g,u,v)|: delete the single edge $uv$ from $g$.
  \item \verb|delete(g,vlist)|: delete a list of vertices from
    $g$. The argument \verb|vlist| must be a one-dimensional array.
  \item \verb|delete(g,elist)|: delete a list of edges from $g$. The
    argument \verb|elist| must be a two-dimensional array with exactly
    two columns. 
  \end{itemize}
  Note: There is an ambiguity if the second argument is a $1\times2$
  array. In this case, the action taken is to delete two vertices;
  that is, we interpret this call as \verb|delete(vlist)|. 
d350 1
d352 7
a358 6
\oitem \verb|dfstree|: depth-first spanning tree. The syntax is
  \verb|dfstree(t,g,v)|. This overwrites $t$ with the depth-first
  spanning tree of $g$ rooted at $v$. If $g$ is not connected, the
  tree spans only the vertices in $v$'s components; the other vertices
  appear as isolates in $t$. The third argument is optional; if
  omitted, we take $v=1$. 
d360 2
a361 7
\oitem \verb|disjoint_union|: form the disjoint union of two
  graphs. This is the syntax:
\begin{verbatim}
disjoint_union(g,h,k)
\end{verbatim}
  This overwrites $g$ with the disjoint union of $h$ and $k$. If both
  $h$ and $k$ have embeddings, their embeddings are combined.
d363 2
d366 4
a369 59
\item \verb|display|: output for graphs. When \matlab\ expects to
  write a graph to the console, it calls this method to format the
  output. A typical output looks like this:
\begin{verbatim}
Graph with 16 vertices and 37 edges (full)
\end{verbatim}
  
\item \verb|dist|: find distances between vertices in a graph. The
  syntax \verb|dist(g,v,w)| finds the distance between vertices $v$
  and $w$ in $g$. (If there is no $v,w$-path, we return $\infty$.)

  The syntax \verb|dist(g,v)| returns a vector whose $i^{\text{th}}$
  entry is the distance from $v$ to $i$.

  Finally, the syntax \verb|dist(g)| returns a square matrix whose
  $i,j$-entry is the distance between vertices $i$ and $j$.

\oitem \verb|distxy|: embed a graph using its distance matrix. The
  syntax is \verb|distxy(g)|. This attempts to embed $g$ so that the
  Euclidean distance between vertices $u$ and $v$ in the embedding
  matches the graph-theoretic distance between $u$ and $v$. 

\oitem \verb|dodecahedron|: generate the dodecahedron graph. The syntax
  \verb|dodecahedron(g)| overwrites $g$ with the dodecahedron graph
  with a nice planar embedding. 


\item \verb|dom|: domination number. The syntax is 
  \verb|[d,S]=dom(g)|. Returns $d$, the domination number
  of $g$, and a minimum size dominating set, $S$. 
  (A subset of vertices $S$ is a dominating set of a graph if every
  vertex of the graph either is in $S$ or is adjacent to a vertex of
  $S$.) 

  Note that finding the domination number of a graph is
  \textsc{np}-hard, so this will work slowly (if at all) on larger
  graphs. Also, this uses \matlab's \verb|bintprog|  which requires
  the Optimization Toolbox. 


\item \verb|dot|: save for processing by \verb|graphviz|. The syntax
  is \verb|dot(g,filename)| where \verb|filename| is the name of the
  file (which should end \verb|.dot|). If \verb|filename| is omitted,
  a default file name is provided. This saves the graph $g$ for
  processing by programs in the \verb|graphviz| package (such as
  \verb|dot|, \verb|neato|, etc.). 

  Note: If the graph is labeled (see \verb|is_labeled|), then we use
  the vertex labels instead of the vertex numbers. In this case, it is
  important that distinct vertices have distinct labels.

  The following figure was formed by creating a $4$-cube, saving it in
  \verb|dot| format, and then creating a layout with the \verb|dot|
  program. 

  \begin{figure}[ht]
    \includegraphics[scale=0.4]{cube}
    \label{fig:cube-dot}
  \end{figure}
d371 8
d381 1
a381 13
\oitem \verb|draw|: draw a graph in a window. The syntax is
  \verb|draw(g)|. This draws $g$ in its current embedding.  The
  vertices are drawn as small circles. If the lengths of the edges are
  about $1$, this gives nice proportions.  If $g$ does not have an
  embedding, one is provided for it (a circle embedding courtesy of
  \verb|embed|).
  
  This may be called with an optional second argument specifying the
  line style. For example, \verb|draw(g,':')| draws the edges as
  dotted lines. The usual \matlab\ line styles are used:
  \verb|'-'|~for a solid line, \verb|'--'|~for a dashed line,
  \verb|':'|~for a dotted line, \verb|'-.'|~for a dash-dot line, and
  \verb|'none'|~for no line.
d383 8
a390 1
  See also \verb|ndraw| and \verb|ldraw|. 
d392 2
a393 3
\item \verb|edges|: list the edges in a graph. The syntax is
  \verb|edges(g)|. This returns a two-column array listing the edges
  of $g$. 
d395 2
a396 4
\oitem \verb|embed|: specify a graph's embedding. The syntax
  \verb|embed(g,xy)| sets $g$'s embedding to the $n\times2$-matrix
  \verb|xy|. If \verb|xy| is omitted, a circular embedding is
  created. 
d398 3
a400 4
\item \verb|euler_trail|: find an Euler trail in a graph. The syntax
  is \verb|euler_trail(g)|. If $g$ has an Euler trail, then this
  returns that trail as an $m\times2$-array. If no trail exists, we
  return an empty matrix. 
d402 5
a406 6
  This can be called with two output arguments:
\begin{verbatim}
[etrail,exists] = euler_trail(g)
\end{verbatim}
  The second argument is set to $1$ (true) if the graph has an Euler
  trail and $0$ (false) if not.
d408 4
a411 8
\item \verb|find_path|: find a shortest path between specified
  vertices. This is the syntax:
\begin{verbatim}
find_path(g,u,v) 
\end{verbatim}
  This returns a shortest $u,v$-path or \verb|[]| if no such path
  exists (including the case when $u$ or $v$ is not in $g$). If $u=v$
  is a vertex of $g$, then we return the one-element list \verb|[u]|.
d413 2
d416 3
a418 5
\oitem \verb|free|: remove a graph from the system. The usual syntax is
  \verb|free(g)| where $g$ is a graph handle. This destroys the graph
  pointed to by $g$ and makes $g$ an invalid handle. It is also
  possible to use the syntax \verb|free(j)| where $j$ is an integer.
  This frees up slot $j$ in the hidden data structure. 
d420 2
a421 4
\oitem \verb|full|: convert to full storage. The syntax is
  \verb|full(g)|. This converts the matrix for $g$ into ``full''
  storage class. This is the preferred format for small and/or dense
  graphs.
d423 4
d428 5
a432 4
\item \verb|get_label|: get a vertex's label or all labels. The syntax
  \verb|get_label(g,v)| returns the label assigned to vertex $v$ and
  the syntax \verb|get_label(g)| returns a cell array containing all
  the labels. 
a433 3
\item \verb|getxy|: get a graph's embedding. The syntax is
  \verb|getxy(g)|. This returns an $n\times 2$ array containing $g$'s
  embedding. 
a434 13
\item \verb|graph|: Constructor for the graph class. The syntaxes for
  this are as follows:
  \begin{itemize}
  \item \verb|g = graph|. Makes $g$ a handle to a new graph (with no
    vertices).
  \item \verb|g = graph(n)|. Makes $g$ a handle to a new graph with
    $n$ vertices. If $n$ is ``small'', $g$ has full storage;
    otherwise, $g$ is set to sparse storage.  (The threshold between
    large and small is set using \verb|set_large|.)  The
    graph has no edges.
  \item \verb|h = graph(g)|. Create an independent clone of $g$ in
    a new graph $h$. 
  \end{itemize}
d436 2
a437 99
  
\oitem \verb|grid|: create a grid graph. The syntax is
  \verb|grid(g,a,b)|. Creates the graph $P_a \times P_b$ with a
  sensible embedding.


\item \verb|has|: determine if a graph has a particular vertex or
  edge. When called as \verb|has(g,v)| we return true ($1$) iff
  $v$ is a vertex of $g$. When called as \verb|has(g,u,v)| we return
  true iff $g$ contains the edge $uv$.  The function form
  \verb|g(u,v)| is equivalent to \verb|has(g,u,v)|. 

\item \verb|has_path|: determine if a graph has a path between
  specified vertices. The syntax is \verb|has_path(g,x,y)|. This
  returns $1$ (true) if there is an $x,y$-path in $g$ and $0$ (false)
  otherwise. 

\item \verb|hasxy|: determine if the graph has an embedding. The
  syntax is \verb|hasxy(g)|. Returns true ($1$) if $g$ has an
  embedding and false otherwise. 

\oitem \verb|icosahedron|: generate the icosahedron graph. The syntax
  \verb|icosahedron(g)| overwrites $g$ with the icosahedron graph with
  a nice planar embedding. 

\item \verb|incidence_matrix|: create the vertex/edge incidence
  matrix. If $g$ is a graph with $n$ vertices and $m$ edges, then
  \verb|incidence_matrix(g)| returns an $n\times m$ matrix whose
  $i,j$-entry is $1$ iff vertex $i$ is an end point of edge $j$. 


\oitem \verb|induce|: create induced subgraphs. The syntax
  \verb|induce(g,vset)| overwrites $g$ with its induced subgraph on
  vertex set \verb|vset|. The syntax \verb|induce(g,h,vset)|
  overwrites $g$ with the induced subgraph of $h$ on vertex set
  \verb|vset|. 
  
\item \verb|intersect|: graph intersection. The syntax is
  \verb|intersect(g,h,k)|. This sets $g$ to the graph with $V(g) =
  V(h) \cap V(k)$ and $E(g) = E(h) \cap E(k)$. 
  
\oitem \verb|interval_graph|: create an interval graph. The syntax is
  \verb|interval_graph(g,ilist)| where \verb|ilist| is an $n\times 2$
  array. Each row of \verb|ilist| represents a real interval
  $[a_i,b_i]$. The graph $g$ has $n$ vertices in which $ij$ is an edge
  if and only if $[a_i,b_i]\cap[a_j,b_j]\not=\emptyset$.

\item \verb|is_labeled|: determine if the vertices have labels. The
  syntax is \verb|is_labeled(g)|.

\item \verb|isconnected|: determine if the graph is connected. The
  syntax is \verb|isconnected(g)|. Returns true ($1$) if $g$ is
  connected and false otherwise. A graph with no vertices is
  considered connected.

\item \verb|isfull|: determine if a graph's storage is full. The
  syntax is \verb|isfull(g)|. Returns 1 (true) if the graph's matrix
  is stored in full storage mode or 0 (false) if not (i.e., if it is
  sparse).

\item \verb|issparse|: determine if a graph's storage is sparse. The
  syntax is \verb|issparse(g)|. Returns 1 (true) if the graph's matrix
  is stored in sparse storage mode or 0 (false) if not (i.e., if it is
  full). 

\oitem \verb|join|: join of two graphs. The syntax is
  \verb|join(g,h,k)|. This overwrites $g$ with the join of $h$ and
  $k$. That, is $g \gets \overline{ \overline{h} + \overline{k}}$.
  
\oitem \verb|label|: label vertices of a graph. The syntax is
  \verb|label(g,v,str)|. This assigns to $v$ the string in the
  variable \verb|str|. The syntax \verb|label(g)| gives every vertex a
  default label (a string version of its number). 
  
\item \verb|laplacian|: find the Laplacian matrix of a graph. The
  syntax is \verb|laplacian(g)|. This returns the matrix $D-A$ where
  $D$ is the diagonal matrix of the degrees of $g$ and $A$ is the
  adjacency matrix of $g$. 

\item \verb|ldraw|: just like \verb|ndraw|, but use vertex labels
  instead of vertex numbers. May be called either \verb|ldraw(g)| or
  \verb|ldraw(g,line_style)|. 

  The labels are written starting in the middle of the vertex and then
  extending to the right. This tends to give ugly results. A better
  solution is to save the graph in \verb|dot| format and use a
  \verb|graphviz| layout program. 

  See \verb|ndraw| and \verb|dot|.


\oitem \verb|line_graph|: find the line graph of a graph. The syntax
  is \verb|line_graph(g,h)|. This overwrites $g$ with $L(h)$, the line
  graph of $h$.
  
\oitem \verb|load|: read a graph from disk. The syntax is
  \verb|load(g,filename)|. This reads the file named in
  \verb|filename| (previously saved by \verb|save|) and overwrites $g$
  with the result.
d439 8
a446 9
  
\item \verb|matrix|: get the adjacency matrix of a graph. The syntax
  is \verb|matrix(g)|. This returns a copy of the adjacency matrix for
  the graph $g$.
  
\item \verb|ndraw|: draw a graph with numbered labels. The syntax is
  the same as for \verb|draw|: \verb|ndraw(g)| or
  \verb|ndraw(g,line_style)|. This draws $g$ in the same way as
  \verb|draw|, but adds a numeric label to each vertex.
d448 3
a450 8
  See also \verb|ldraw|.
  
\item \verb|ne|: number of edges. The syntax is \verb|ne(g)|. Returns
  the number of edges in the graph $g$.
  
\item \verb|nsptrees|: number of spanning trees. The syntax is
  \verb|nsptrees(g)|. This returns the number of spanning trees of
  $g$. Of course, we use the matrix-tree theorem to find this result.
d452 1
a452 3
  
\item \verb|nv|: number of vertices. The syntax is \verb|nv(g)|.
  Returns the number of vertices in the graph $g$.
a453 45
  
\item \verb|neighbors|: find the neighbor set of a vertex. The syntax
  is \verb|neighbors(g,v)|. This returns a list of the neighbors of
  $v$ in $g$. This is equivalent to \verb|g(v)|.
  
\oitem \verb|octahedron|: generate the octahedron graph. The syntax
  \verb|octahedron(g)| overwrites $g$ with the octahedron graph,
  $K_{2,2,2}$, with a nice planar embedding.


\item \verb|omega|: clique number. Calling \verb|omega(g)| returns the
  size of a largest clique in $g$. Calling \verb|[w,S]=omega(g)|
  returns $\omega(g)$ in $w$ and a maximum clique in $S$.

  Note: This method uses integer programming; hence it requires
  \matlab's optimization toolbox and may run slowly (if at all) on
  large graphs. 

\oitem \verb|path|: create a path graph. The syntax is
  \verb|path(g,n)|. This overwrites $g$ with the graph $P_n$ (path on
  $n$ vertices). An embedding (all vertices in order on a line) is
  automatically provided. 

\oitem \verb|paley|: create a Paley graph. The syntax is
  \verb|paley(g,n)|. This overwrites $g$ with the Paley graph created
  by $\ZZ_n$. In this graph, there is an edge between $i$ and $j$ iff
  $i-j$ is a square in $\ZZ_n$. In order for this to work, $-1$ must
  be a square in $\ZZ_n$; if it isn't, an error results. 

\oitem \verb|petersen|: create the Petersen graph. The syntax is
  \verb|petersen(g)|. This overwrites $g$ with the Petersen graph with
  a classic embedding. 


\oitem \verb|random|: overwrite a graph with a random graph. The
  syntax is \verb|random(g,n,p)| which overwrites $g$ with an \ER\ 
  random graph $G(n,p)$.

  This function may also be called as \verb|random(g,p)| which
  overwrites $g$ with a $G(n,p)$ where $n$ is the number of vertices
  in $g$. And it may also be called simply as \verb|random(g)| which
  is equivalent to \verb|random(g,0.5)|. 
  
  If $n$ is large, consider \verb|sprandom| to create a large, sparse
  random graph.
d455 2
a456 5
\oitem \verb|random_bipartite|: generate a random bipartite graph. The
  syntax is \verb|random(g,n,m,p)|. This overwrites $g$ with a random
  bipartite graph with part sizes $n$ and $m$ (positive integers) and
  edge probability $p$. If $p$ is omitted, the default value $\frac12$
  is used. 
d458 7
a464 3
\oitem \verb|random_regular|: create a random regular graph. The syntax
  is \verb|random_regular(g,n,k)|. This overwrites $g$ with a random
  regular graph on $n$ vertices with degree $k$. 
d466 4
a469 3
  The algorithm works pretty well for small $k$. There are better
  algorithms than the one we implemented, but this one was easy to
  code.
d471 6
d478 11
a489 3
\oitem \verb|random_tree|: generate a random tree. The syntax is
  \verb|random_tree(g,n)|. This overwrites $g$ with a random tree on
  $n$ vertices. 
d492 2
a493 7
\oitem \verb|renumber|: renumber vertices of a graph according to a
  permutation. The syntax is \verb|renumber(g,p)|. Here $p$ is a
  permutation of $\{1,2,\ldots,n\}$ where $n$ is the number
  of vertices in $g$. Vertex $1$ of $g$ is renamed $p(1)$, etc. 
  
  Note: $p$ may be either an $n$-long array or a permutation object.
  See Section~\ref{sect:perms}.
d495 2
a496 2
  Note: This method used to be named \verb|relabel|, but we now have a
  notion of a vertex label so that takes on a new meaning. 
d498 7
a504 14
\oitem \verb|resize|: change the size of a graph. The syntax is
  \verb|resize(g,n)|. This changes the number of vertices in $g$ to
  $n$. If $n$ is smaller than the number of vertices in $g$, then
  vertices $n+1$ and up are deleted. If $n$ is greater than the number
  of vertices in $g$, then additional isolated vertices are added to
  the graph. If $n$ equals the number of vertices in $g$, then no
  change is made.

\oitem \verb|rmxy|: remove a graph's embedding. The syntax is
  \verb|rmxy(g)|. This clears $g$'s embedding (if it has one). 

\item \verb|save|: save a graph to disk. The syntax is
  \verb|save(g,filename)|. This writes $g$ to disk. The graph can
  later be read back in using \verb|load|. 
d506 4
a509 16
  
\item \verb|size|: report the number of vertices and edges. The syntax
  is \verb|size(g)|. This returns a two-element row containing the
  number of vertices and number of edges in $g$. (This is a deliberate
  overloading of \matlab's \verb|size| function. It also means that a
  graph with, say, $10$ vertices and $15$ edges is reported as a 
  \verb|<10x15 graph>| in \matlab's workspace.)
  
  This may also be called with two output arguments:
  \verb|[n,m]=size(g)|. This is equivalent to the pair of statements
  \verb|n=nv(g)| and \verb|m=ne(g)|.
  
\item \verb|slot|: get the slot number of a graph. The syntax is
  \verb|slot(g)|. This returns the slot number that holds the graph
  $g$. There is little reason a user of this toolbox would need to
  call this function. 
d511 11
a521 2
\oitem \verb|sparse|: convert to sparse storage. The syntax is
  \verb|sparse(g)|. This converts the graph $g$ to sparse storage. 
d523 12
a534 6
  
\item \verb|split|: partition the graph. The syntax is
  \verb|part=split(g)|. This partitions the vertex set of $g$ into two
  disjoint subsets based on the signs of the entries of the
  eigenvector associated with the second smallest eigenvalue of the
  Laplacian of $g$.
d536 18
d555 4
d560 3
a562 25
\item \verb|sprandom|: create a sparse random graph. The syntax is
  \verb|sprandom(g,n,p)|. The overwrites $g$ with an \ER\ random graph
  with $n$ vertices and edge probability $p$. This is useful when $n$
  is large and $p$ is small.

\oitem \verb|springxy|: find a spring embedding of a graph. The syntax
  is \verb|springxy(g)|. The vertices of $g$ are modeled as charged
  particles and the edges as springs. We attempt to minimize the
  energy of the configuration.  If $g$ already has an embedding, we
  use that embedding as the starting point of the optimization. If $g$
  does not have an embedding, a random embedding is used as the
  initial configuration. 

  The optimizer runs for a maximum number of iterations that is linear
  in the number of vertices. This function returns the
  energy level of the system. If repeated calls to \verb|springxy| do
  not appreciably change the energy level, the optimizer is probably
  stuck at a local minimum. 
  
  This routine isn't working well. It is slow, calls \matlab's
  \verb|lsqnonlin|, and I'm not happy with the pictures. It seems that
  the optimizer often gets stuck in local minima. Finally, this
  function requires the Optimization Toolkit and won't work for users
  who have not purchased this \matlab\ add-on. In short, this needs
  work.
d564 2
a565 4
  
\item \verb|spy|: invoke \matlab's \verb|spy| function on the
  adjacency matrix of a graph. The syntax is \verb|spy(g)|.
  
d567 1
d569 6
a575 9
\oitem \verb|trim|: iteratively remove vertices of small degree. The
  syntax is \verb|trim(g,d)|. This deletes all vertices of degree at
  most $d$ from $g$, and the repeats on the subgraph that
  results. This continues until all vertices are deleted or the
  minimum degree is greater than $d$. Calling \verb|trim(g)| is
  equivalent to \verb|trim(g,0)|. 
  
\oitem \verb|union|: graph union. The syntax is \verb|union(g,h,k)|.
  This sets $V(g) = V(h) \cup V(k)$ and $E(g) = E(h) \cup E(k)$.
d577 1
a577 3
\oitem \verb|wheel|: create a wheel graph. The syntax is
  \verb|wheel(g,n)|. This overwrites $g$ with a wheel on $n$
  vertices. If $n$ is omitted, the number of vertices in $g$ is used. 
d579 9
a588 1
\end{itemize}
d591 1
a591 1
\subsection{Matgraph system functions}
d593 2
a594 1
These functions are used for the management of the Matgraph system.
d596 2
a597 1
\begin{itemize}
d599 6
a604 5
\item \verb|find_available|: find first available slot in
  \verb|GRAPH_MAGIC|. Used by the constructor, \verb|graph|, this
  function finds the first available slot in the \verb|GRAPH_MAGIC|
  structure (or 0 if no slots are available). No reason users should
  call this.
d606 5
d612 6
a617 3
\item \verb|free_all|: remove all graphs from the system. All graph
  handles are invalid once this is invoked.
  
d619 2
a620 2
\item \verb|graph_destroy|: Wipe out the \verb|GRAPH_MAGIC|
  system. This eradicates the effect of \verb|graph_init|. 
d622 12
a633 1
  
d635 2
a636 24
\item \verb|graph_init|: initialize the graph toolbox. This function
  initializes the \verb|GRAPH_MAGIC| structure. The syntax is
  \verb|graph_init(capacity)|; this sets up a data structure that can
  hold \verb|capacity| graphs. It is automatically called the first
  time a graph is declared using the \verb|graph| constructor.

\item \verb|graph_system_exists|: determine if the system has been
  initialized (via \verb|graph_init|). Returns 1 if the system has
  been initialized and 0 if not.


\item \verb|max_available|: return the  number of slots in the
  \verb|GRAPH_MAGIC| data structure. 

\item \verb|num_available|: returns the number of unused slots
  available in the system.

\item \verb|set_large|: change the definition of a ``large''
  graph. The syntax is \verb|set_large(n)|. With this, graphs on $n$
  or fewer vertices are considered ``small'' and given full storage;
  graphs on more than $n$ vertices are ``large'' and given sparse
  storage.  (Whether or not a graph is full or sparse is set when the
  constructor is invoked and can be changed by \verb|full| and
  \verb|sparse|.)
a637 2
  If \verb|set_large| is called without arguments, it returns the
  value currently held for this threshold. 
a638 1
\end{itemize}
a641 1
\subsection{Operators} 
a642 2
\textbf{WARNING: These operators are DEPRECATED. I plan to remove or
  replace them.}
a644 4
We provide the following graph operators. It is not clear if we'll
continue to support these because they are tricky to use. In each
case, the operator creates a new graph. Unless the result of the
operation is saved in a variable, unrecoverable memory is wasted. 
d646 2
a647 3
\begin{itemize}
\item \verb|g+h|: this creates a new graph equal to the disjoint union
  of $g$ and $h$.
d649 9
a657 2
\item \verb|g*h|: this creates a new graph equal to the Cartesian
  product $g \times h$. 
a658 6
\item \verb|-g|: this creates a new graph equal to the complement of
  $g$.
\end{itemize}
We also provide operator syntax for \verb|neighbors| and
\verb|has|. These are safe to use (but I have had some problems using
them inside \verb|.m| files).
d660 5
a664 2
\begin{itemize}
\item \verb|g(v)|: this returns the neighbor set of $v$.
d666 2
a667 3
\item \verb|g(v,w)|: this returns $1$ (true) if $vw$ is an edge of $g$
  and $0$ otherwise.
\end{itemize}
a669 1
\subsection{Commands by category}
a670 1
The following charts give all the functions organized by category.
a671 130
\bigbreak
\begin{tabular}[ht]{|l|l|}
  \hline
  System commands
  & \verb|graph_init| \\
  & \verb|graph_destroy| \\
  & \verb|graph_system_exists| \\
  & \verb|max_available| \\
  & \verb|num_available| \\ 
  & \verb|find_available| \\
  & \verb|set_large| \\ 
  & \verb|slot| \\
  \hline
\end{tabular}
\bigbreak
\begin{tabular}[ht]{|l|l|}
  \hline
  Graph declaration/deallocation 
  & \verb|graph| \\ 
  & \verb|free| \\ 
  & \verb|free_all| \\
  \hline
\end{tabular}
\bigbreak
\begin{tabular}[ht]{|l|l|}
  \hline
  Graph queries 
  & \verb|across| \\
  & \verb|alpha| \\
  & \verb|bipartition| \\ 
  & \verb|bipmatch| \\ 
  & \verb|color| \\
  & \verb|chromatic_polynomial| \\ 
  & \verb|components| \\ & \verb|deg| \\ & \verb|dist| \\ 
  & \verb|dom| \\
  & \verb|edges| \\ 
  & \verb|euler_trail| \\ 
  & \verb|find_path| \\ 
  & \verb|has| \\ 
  & \verb|has_path| \\ 
  & \verb|incidence_matrix| \\
  & \verb|isconnected| \\ 
  & \verb|laplacian| \\
  & \verb|matrix| \\ & \verb|ne| \\ & \verb|nsptrees| \\ 
  & \verb|nv| \\ & \verb|neighbors| \\ 
  & \verb|omega| \\
  & \verb|size| \\
  \hline
\end{tabular}
\bigbreak
\begin{tabular}[ht]{|l|l|}
  \hline
  Graph building operations &
  \verb|add|\\ & \verb|contract|\\ & 
  \verb|delete|\\ & \verb|clear_edges|\\ & 
  \verb|copy|\\ & \verb|induce|\\ & 
  \verb|renumber|\\ & \verb|trim| \\
  \hline
\end{tabular}
\bigbreak
\begin{tabular}[ht]{|l|l|}
  \hline
  Graph class builders &
  \verb|cube| \\ & \verb|complete| \\ & 
  \verb|cycle| \\ & \verb|dodecahedron| \\ &
  \verb|grid| \\ &
  \verb|icosahedron| \\ &
  \verb|interval_graph| \\ & \verb|line_graph| \\ &
  \verb|octahedron| \\ & \verb|path| \\ & \verb|paley| \\ &
  \verb|petersen| \\ 
  & \verb|random| \\ 
  & \verb|random_bipartite| \\
  & \verb|random_regular| \\
  & \verb|random_tree| \\
  & \verb|sprandom| \\ & \verb|wheel| \\
  \hline
\end{tabular}
\bigbreak
\begin{tabular}[ht]{|l|l|}
  \hline
  Graph operations &
  \verb|bfstree| \\ & \verb|cartesian| \\ & 
  \verb|complement| \\ & \verb|dfstree| \\ &
  \verb|disjoint_union| \\ & \verb|intersect| \\ & 
  \verb|join| \\ &
  \verb|line_graph| \\ 
  & \verb|union| \\ 
  \hline
\end{tabular}

\bigbreak
\begin{tabular}[ht]{|l|l|}
  \hline
  Vertex labels &
  \verb|clear_labels| \\ &
  \verb|get_labels| \\ & 
  \verb|is_labeled| \\ & 
  \verb|label| \\ 
  \hline
\end{tabular}

\bigbreak
\begin{tabular}[ht]{|l|l|}
  \hline
  Visualization &
  \verb|distxy| \\ &
  \verb|draw| \\ & \verb|embed| \\ & \verb|getxy| \\ 
  & \verb|hasxy| \\ & 
  \verb|ldraw| \\ &
  \verb|ndraw| \\ &
  \verb|rmxy| \\ & \verb|springxy| \\ & \verb|spy| \\
  \hline
\end{tabular}
\bigbreak
\begin{tabular}[ht]{|l|l|}
  \hline 
  Storage type &
  \verb|full|\\ & \verb|isfull|\\ & 
  \verb|issparse|\\ & \verb|sparse| \\
  \hline
\end{tabular}
\bigbreak
\begin{tabular}[ht]{|l|l|}
  \hline
  Saving to disk &
  \verb|dot|\\ &
  \verb|load|\\ & 
  \verb|save| \\
  \hline
\end{tabular}
d681 3
a683 1
\matlab\ conventions and do not need to be specially declared.
d900 1
d1023 6
a1028 1
  \verb|graph_edit(g)|. 
a1029 16


\section{Open Source}

This software is copyrighted by Edward R.~Scheinerman and released
free of charge under the GNU General Purpose Licences. A copy of this
licence can be found at
\begin{verbatim}
http://www.gnu.org/licenses/gpl.html
\end{verbatim}

I would like to make this tool as useful to as many people as
possible. I invite you to send me improvements for the current
\verb|.m| files as well as new \verb|.m| files for added
functionality. 

@


1.21
log
@*** empty log message ***
@
text
@d3 2
d31 7
a37 1
been added to Matgraph since this has been updated. See the web pages.
d152 3
a154 3
\verb|add(g,u,v)| adds the edge $uv$ to $g$. However, if $u$ or $v$
are out of range (less than $1$ or greater than the number of vertices
in $g$), then the command has no effect. 
d228 3
a230 3
  $g$. Note that if $u=v$ or if either $u$ or $v$ are out of range
  (nonpositive or larger than the number of vertices in $g$), then no
  edge is added (and no warning is given). 
d904 4
d1411 7
a1417 2
\item The current \verb|springxy| routine is slow and gives lousy
  results. A better version is needed. 
@


1.20
log
@*** empty log message ***
@
text
@d27 3
@


1.19
log
@*** empty log message ***
@
text
@d710 16
d992 7
a998 2
  \verb|octahedron| \\ & \verb|path| \\ & \verb|paley| \\ & \verb|petersen| \\ &
  \verb|random| \\ & \verb|sprandom| \\ & \verb|wheel| \\
d1009 2
a1010 1
  \verb|line_graph| \\ & \verb|union| \\ 
@


1.18
log
@*** empty log message ***
@
text
@d473 1
a473 1
  See also \verb|ndraw|.
d620 12
d650 2
d1009 3
a1011 1
  & \verb|hasxy| \\ & \verb|ndraw| \\ &
@


1.17
log
@*** empty log message ***
@
text
@d4 1
a4 1
%\usepackage{courier}
d446 11
a456 1
  important that distinct vertices have distinct labels!
@


1.16
log
@*** empty log message ***
@
text
@d444 5
@


1.15
log
@*** empty log message ***
@
text
@d27 2
d161 11
d284 3
d436 8
d503 4
d573 3
d595 5
d686 2
a687 2
\oitem \verb|relabel|: relabel vertices of a graph according to a
  permutation. The syntax is \verb|relabel(g,p)|. Here $p$ is a
d690 3
d694 2
a695 2
  Note that $p$ may be either an $n$-long array or a permutation
  object. See Section~\ref{sect:perms}.
d935 1
a935 1
  \verb|relabel|\\ & \verb|trim| \\
d962 12
d996 3
a998 1
  \verb|load|\\ & \verb|save| \\
d1052 1
@


1.14
log
@*** empty log message ***
@
text
@d212 9
d408 12
d523 6
d608 9
d681 4
d868 1
d874 1
d876 3
a878 1
  & \verb|euler_trail| \\ & \verb|find_path| \\ & \verb|has| \\ 
d880 1
d883 4
a886 2
  & \verb|matrix| \\ & \verb|ne| \\ & \verb|nsptrees| \\ &
  \verb|nv| \\ & \verb|neighbors| \\ & \verb|size| \\
d1001 1
a1001 1
  $p==q$. 
d1029 1
a1029 1
\item \verb|mtimes|: composition. The syntax is $p*q$ where $p$ and
@


1.13
log
@*** empty log message ***
@
text
@d277 1
a277 1
  Eventually, we expect to add other coloring algorithms. 
@


1.12
log
@*** empty log message ***
@
text
@d261 18
d829 3
a831 1
  & \verb|bipmatch| \\ & \verb|chromatic_polynomial| \\ 
@


1.11
log
@*** empty log message ***
@
text
@d635 1
a635 1

d638 3
a640 4
  disjoint subsets returned in \verb|part{1}| and \verb|part{2}|. This
  partition is based on the signs of the entries of the eigenvector
  associated with the second smallest eigenvalue of the Laplacian of
  $g$. 
d1009 14
a1022 3
$\{1,2,\ldots,n\}$.

\textsf{Documentation needs to be written; functions are as follows:}
d1024 1
a1024 8
check
display
np
nv
partition
parts
size
subsref
d1027 75
@


1.10
log
@*** empty log message ***
@
text
@d225 1
a225 1
part = bipartition(g)
d227 4
a230 4
  If $g$ is a bipartite graph, this returns disjoint subsets $X$ and
  $Y$ of $V(g)$ so that $X,Y$ is a bipartition ($2$-coloring) of $g$.
  These sets are returned in the cell array, \verb|part|. That is,
  \verb|part{1}| holds $X$ and \verb|part{2}| holds $Y$. 
d232 1
a232 1
  If $g$ is not bipartite, this returns an empty cell array. 
d235 8
a242 9
  graph. This is the
  syntax:
\begin{verbatim}
bipmatch(g,X,Y)
\end{verbatim}
  Here, $g$ is a graph and $X,Y$ are disjoint subsets of $V(g)$. This
  function finds a maximum matching on the bipartite (sub)graph of $g$
  with bipartition $X \cup Y$. This function returns an $m\times2$
  list of the edges in a maximum matching.
d597 2
a598 2
  permutation. The syntax is \verb|relabel(g,p)|. Here $p$ is an
  $n$-long permutation of $\{1,2,\ldots,n\}$ where $n$ is the number
d601 3
d882 141
@


1.9
log
@*** empty log message ***
@
text
@d9 3
a11 2
\address{Department of Applied Mathematics and Statistics, The Johns
  Hopkins University, Baltimore, Maryland 21218-2682 USA}
d196 6
d225 1
a225 1
[X,Y] = bipartition(g)
d229 4
a232 1
  If $g$ is not bipartite, this returns two empy arrays.
d481 1
a481 1
\oitem |icosahedron|: generate the icosahedron graph. The syntax
a489 1

d520 5
d634 8
d808 10
a817 4
  & \verb|bipartition| \\ & \verb|bipmatch| \\ & \verb|chromatic_polynomial| \\ &
  \verb|components| \\ & \verb|deg| \\ & \verb|dist| \\ & \verb|edges| \\ &
  \verb|euler_trail| \\ & \verb|find_path| \\ & \verb|has| \\ & \verb|has_path| \\ &
  \verb|isconnected| \\ & \verb|matrix| \\ & \verb|ne| \\ & \verb|nsptrees| \\ &
@


1.8
log
@*** empty log message ***
@
text
@d4 1
a4 1
\usepackage{courier}
@


1.7
log
@*** empty log message ***
@
text
@d3 2
d18 4
d257 3
d352 20
d471 4
d514 1
a514 1

d520 5
a524 5

\item \verb|matrix|: get the adjacency matrix of a graph. The syntax is
  \verb|matrix(g)|. This returns a copy of the adjacency matrix for
  the graph $g$. 

d528 2
a529 2
  \verb|draw|, but adds a numeric label to each vertex. 

d535 1
a535 2
  $g$. Of course, we use the matrix-tree theorem to find this result. 

d537 1
d541 8
a548 5

\item \verb|neighbors|: find the neighbor set of a vertex. The syntax is
  \verb|neighbors(g,v)|. This returns a list of the neighbors of $v$
  in $g$. This is equivalent to \verb|g(v)|. 

d578 4
d757 1
a757 51
Here is a brief summary of the all the functions listed by category.


\subsubsection*{System commands}

\verb|graph_init|, \verb|graph_destroy|, \verb|graph_system_exists|,
\verb|max_available|, \verb|num_available|, \verb|find_available|,
\verb|set_large|, \verb|slot|.


\subsubsection*{Graph declaration/deallocation}

\verb|graph|, \verb|free|, \verb|free_all|.

\subsubsection*{Graph queries}

\verb|bipartition|, \verb|bipmatch|, \verb|chromatic_polynomial|,
\verb|components|, \verb|deg|, \verb|edges|, \verb|euler_trail|,
\verb|find_path|, \verb|has|, \verb|has_path|, \verb|isconnected|,
\verb|matrix|, \verb|ne|, \verb|nsptrees|, \verb|nv|,
\verb|neighbors|, \verb|size|.

\subsubsection*{Graph building operations}

\verb|add|, \verb|contract|, \verb|delete|, \verb|clear_edges|, \verb|copy|,
\verb|induce|, \verb|relabel|, \verb|trim|.

\subsubsection*{Graph class builders}

\verb|cube|, \verb|complete|, \verb|cycle|, \verb|grid|,
\verb|interval_graph|, \verb|line_graph|, \verb|path|, \verb|paley|,
\verb|petersen|, \verb|random|, \verb|sprandom|, \verb|wheel|. 

\subsubsection*{Graph operations}

\verb|bfstree|, \verb|cartesian|, \verb|complement|, \verb|dfstree|,
\verb|disjoint_union|, \verb|intersect|, \verb|join|,
\verb|line_graph|, \verb|union|.

\subsubsection*{Visualization}

\verb|draw|, \verb|embed|, \verb|getxy|, \verb|hasxy|, \verb|ndraw|,
\verb|rmxy|, \verb|springxy|, \verb|spy|.

\subsubsection*{Storage type}

\verb|full|, \verb|isfull|, \verb|issparse|, \verb|sparse|. 

\subsubsection*{Saving to disk}

\verb|load|, \verb|save|.
d759 93
@


1.6
log
@*** empty log message ***
@
text
@d1 1
a1 1
\documentclass[11pt]{amsart}
a2 2
\usepackage{charter}
\usepackage{euler}
d23 1
a23 1
  are undirected graphs without loops or multiple edges} graphs in
d65 3
d103 1
a103 1
Matgraph includes several methods for building graphs. One a graph
d116 2
a117 2
  their arguments, but if a graph is modified by a method, only the
  first argument can be modified. 
d164 2
a165 1
\verb|issparse(g)| are used to learn the type in place. 
d179 1
a179 1
arguments, but items marked with an open circle $\circ$ may modify
d182 1
a182 1
never modified. Based on this principle, it is easy to deduce that
d199 1
a199 1

d204 2
a205 1
  appear as isolates in $t$. 
d208 20
a227 12
\item \verb|bipartition|: find a bipartition of a bipartite graph. The
  syntax is \verb|[X,Y]=bipartition(g)|. If $g$ is a bipartite
  graph, this returns disjoint subsets $X$ and $Y$ of $V(g)$ so that
  $X,Y$ is a bipartition ($2$-coloring) of $g$. If $g$ is not
  bipartite, this returns two empy arrays. 

\item \verb|bipmatch|: find maximum matching in a bipartite graph. The
  syntax is \verb|bipmatch(g,X,Y)|. Here, $g$ is a graph and $X,Y$ are
  disjoint subsets of $V(g)$. This function finds a maximum matching
  on the bipartite (sub)graph of $g$ with bipartition $X \cup Y$. This
  function returns an $m\times2$ list of the edges in a maximum
  matching. 
d231 1
a231 1
  product \verb|h \times k|. 
d267 3
a269 1
    with the complete multipartite graph $K(n_1,n_2,\ldots,n_p)$.
d321 1
a321 1
  \verb|bfstree(t,g,v)|. This overwrites $t$ with the depth-first
d324 2
a325 1
  appear as isolates in $t$. 
d328 6
a333 3
  graphs. The syntax is \verb|disjoint_union(g,h,k)|. This overwrites
  $g$ with the disjoint union of $h$ and $k$. If both $h$ and $k$ have
  embeddings, their embeddings are combined.
d373 6
a378 4
  This can be called with two output arguments: 
  \verb|[etrail, exists] = euler_trail(g)|. The second argument is set
  to $1$ (true) if the graph has an Euler trail and $0$ (false) if
  not.
d381 7
a387 4
  vertices. The syntax is \verb|find_path(g,u,v)|. This returns a
  shortest $u,v$-path or \verb|[]| if no such path exists (including
  the case when $u$ or $v$ is not in $g$). If $u=v$ is a vertex of
  $g$, then we return the one-element list \verb|[u]|. 
d394 1
a394 1
  This frees up slot $j$ in the global \verb|GRAPH_MAGIC|.
d430 2
a431 1
  true iff $g$ contains the edge $uv$. 
d509 1
a509 1
\item \verb|neighbors|: find neighbor set of a vertex. The syntax is
d526 2
a527 2
  \verb|petersen(g)|. This overwrites $g$ with the Petersen graph. 

d531 2
a532 2
  standard syntax is \verb|random(g,n,p)| which overwrites $g$ with an
  \ER\ random graph $G(n,p)$. 
d573 2
a574 1
  $g$.
d601 5
a605 6
  \verb|lsqnonlin|, and I'm not happy with the pictures. Repeated
  calls to \verb|springxy| will run the optimization methods more
  giving (rarely) improved pictures. It seems that the
  optimizer often gets stuck in local minima. This will not work for
  people that have not purchased the Optimization Toolkit. In short,
  this needs work.
d665 2
a666 2
\item \verb|max_available|: return the maximum number of slots available in
  the toolbox.
d720 1
a720 1
\subsubsection{System commands}
d727 1
a727 1
\subsubsection{Graph declaration/deallocation}
d731 1
a731 1
\subsubsection{Graph queries}
d733 1
a733 1
\verb|bipartition|, \verb|bipmatch|, \verb|chromatic_polynomial|
d739 1
a739 1
\subsubsection{Graph building operations}
d744 1
a744 1
\subsubsection{Graph class builders}
d750 1
a750 1
\subsubsection{Graph operations}
d756 1
a756 1
\subsubsection{Visualization}
d761 1
a761 1
\subsubsection{Storage type}
d765 1
a765 1
\subsubsection{Saving to disk}
d840 1
a840 1
There are a small suite of tools for working with the queue in the
@


1.5
log
@*** empty log message ***
@
text
@d571 1
a571 1
  in the number of vertices. Before exiting, this function reports the
d575 1
a575 1

d577 1
a577 1
  \verb|fminsearch|, and I'm not happy with the pictures. Repeated
d579 2
a580 2
  giving (perhaps) improved pictures. However, it seems that the
  optimizer gets stuck in local minima. This also might not work for
d582 1
a582 1
  this needs work. 
@


1.4
log
@*** empty log message ***
@
text
@d340 2
d469 4
d562 22
d735 2
a736 2
\verb|draw|, \verb|embed|, \verb|getxy|, \verb|hasxy|, \verb|rmxy|,
\verb|spy|. 
d867 2
a868 2
\item Spring embedding. I would like a good ``force'' embedding that
  automatically generates ``nice'' embeddings of all graphs. 
@


1.3
log
@*** empty log message ***
@
text
@d349 10
d408 5
d682 5
a686 5
\verb|bipartition|,
\verb|bipmatch|, \verb|chromatic_polynomial| \verb|components|,
\verb|deg|, \verb|edges|, \verb|find_path|, \verb|has|,
\verb|isconnected|, \verb|matrix|, \verb|ne|, \verb|nsptrees|,
\verb|nv|, \verb|neighbors|, \verb|size|.
@


1.2
log
@*** empty log message ***
@
text
@d204 7
d667 1
@


1.1
log
@Initial revision
@
text
@d203 7
d487 3
d527 7
a608 2


d660 4
a663 4
\verb|chromatic_polynomial| \verb|components|, \verb|deg|,
\verb|edges|, \verb|find_path|, \verb|has|, \verb|isconnected|,
\verb|matrix|, \verb|ne|, \verb|nsptrees|, \verb|nv|,
\verb|neighbors|, \verb|size|.
d674 1
a674 1
\verb|petersen|, \verb|random|, \verb|wheel|. 
@
